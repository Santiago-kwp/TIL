# 25.07.24.(목) 변수와 데이터, 자바 기초

### 변수와 데이터

> **메모리** : 수많은 번지(주소)들로 구성된 데이터 저장 공간. 프로그램은 데이터를 메모리에 저장하고 읽어 작업을 빈번히 수행한다. 그래서 프로그램은 데이터를 **어디에, 어떤 방식으로 저장하는가를 고민**해야 한다. 저장할지를 정해 놓지 않았다면 메모리 관리가 어려워 진다. 해결하기 위해 변수를 사용한다.
> 

> **변수** : 하나의 값을 저장할 수 있는 메모리 번지(주소)에 붙여진 이름. 프로그램은 변수를 통해서 메모리 번지에 값을 저장하고 읽을 수 있다.
> 

자바의 변수는 다양한 타입의 값을 하나의 공간에 저장할 수 없다.

- 하나의 변수는 하나의 타입의 값을 메모리 주소와 연결함.

- **자바의 데이터 타입**
    - **정수형 데이터 타입 (부호(+,-)가 있는 타입)**
        
        byte(1byte), short(2byte), char(2byte), int(4byte), long(8byte)
        
        - 최상위 비트는 부호 비트로 `0` 이면 양수 
        → n개의 비트라면  0 ~ (2^(n-1) -1 ) 까지 표현 가능
        - 부호 비트가 `1` 이면 음수 
        → n개의 비트라면 -1 ~ -(2^(n-1))까지 표현 가능
        -1 : 1,1,1,1,1,1,1,1
        -2 : 1,1,1,1,1,1,1,0
        - -2를 만들기 위해 2 : 0,0,0,0,0,0,1,0 의 2의 보수를 취함
        → 2의 보수 : 부호 비트를 포함하여 나머지 비트에 대해서 반전한 뒤 1을 더함
        → 1(부호비트), 1,1,1,1,1,0,1 + 1 → 1,1,1,1,1,1,1,0 : -2
    - 코드에서 **프로그래머가 직접 입력한 값 : 리터럴 (literal)**
        - 리터럴 표기법
            - 2진수 : `0B`, `0b`로 시작하고 0과 1로 작성
            - 8진수 : `0` 로 시작하고 0~7 숫자로 작성
            - 10진수 : 앞에 쓰는거 없으면 10진수
            - 16진수 : `0X`, `0x` 로 시작하고 0~9까지 10⇒ A, a 11⇒ B, b ~ 15⇒ F, f
        - 문자 리터럴 : 하나의 문자를 작은 따옴표(’)로 감싼 것
        - 문자 리터럴을 유니코드로 저장할 수 있도록 char 타입 제공
        
    - **실수형 데이터 타입**
        - float(4byte)
        - double(8byte)
    - **불리언 데이터 타입 (true/ false)**
    - **문자열과 String 타입**
        - 문자열은 **재사용이 가능**한 메모리의 **literal constant pool**에 들어감
        - 문자는 재사용 하지 않는 임시 저장을 위한 메모리의 **stack 영역**에 들어감
        - `public final class` : `final`은 더 이상 상속하여 변경할 수 없는 클래스임을 의미함.
        - 이스케이프 문자
            - java14 부터 지원됨 : `“”” ...  “””`
    - 자동 타입변환 ⇒ **프로모션 promotion**
    
    > **자동으로 타입변환이 일어남을 뜻함.**
    값의 허용범위가 작은 타입이 허용범위가 큰 타입으로 대입될 때 발생함. (ex. byte → int)
    * 예외 byte 타입은 char 타입으로 자동 변환될 수 없음
    > 
    > - byte는 signed(부호가 있는) 타입이고, char는 unsigned 타입이므로, 자바의 자동 타입 변환은 데이터 손실이 발생하지 않는 방향으로만 허용됨. 즉, 값의 범위가 완전히 포함되지 않는 byte → char는 자동 변환이 허용되지 않음.
    > - 
    > 
    > 데이터 손실이 발생할 위험이 없기 때문에 컴파일러가 자동으로 처리합니다.
    > 
    > - **누가 하는가?** **컴파일러**
    > - **어떻게?** 컴파일러는 소스 코드를 바이트코드(`.class` 파일)로 변환하는 과정에서 자동 타입 변환이 필요한 부분을 감지하고, 해당 변환에 필요한 **명령어(opcode)**를 바이트코드 내에 삽입합니다.
    >     - 예를 들어, `int` 값을 `long` 변수에 할당하는 경우 `i2l` (int to long)과 같은 변환 명령어가 바이트코드에 포함될 수 있습니다.
    >     - 산술 연산 시에도 자동 프로모션이 일어납니다. `byte`, `short`, `char` 타입의 피연산자는 연산 전에 자동으로 `int` 타입으로 프로모션됩니다. 이 역시 컴파일러가 해당 연산을 `int` 연산으로 처리하도록 바이트코드를 생성합니다.
    > - **JVM의 역할:** 컴파일러가 생성한 바이트코드를 JVM이 실행할 때, 이미 변환 명령어가 포함되어 있으므로 JVM은 그 명령어를 그대로 실행합니다.
    - 강제타입변환 ⇒ **캐스팅(Casting)**
    
    > **기본 강제 타입변환**
    큰 허용범위 타입을 작은 허용 범위 타입으로 쪼개어 저장하는 것. 강제 타입 변환 시 캐스팅 연산자 : () 괄호
    {} : 브레이스 (중괄호), [] : 대괄호, 브라켓 배열선언 시 사용
    * 강제타입변환의 목적은 원래 값이 유지되면서 타입만 바꾸기 위해 등장한 것.
    > 
    > - 자바에서의 간단한 리터럴 연산은 컴파일 시에 해버림
    > `byte result = 10 + 20 // 컴파일 byte result =30`
    > - 변수를 통한 연산은 컴파일에서 일어나지 않고, runtime 환경에서 일어남. 
    > `int result = intValue2 + intValue3 //컴파일 단계에서 일어나지 않고, 메모리에 올린 뒤 실행 시에 연산이 일어남.`
    > - 상위 클래스에서 하위 클래스로의 변환 등 데이터 손실이나 런타임 오류의 가능성이 있는 변환을 수행할 때 사용자가 명시적으로 변환 지시자 `()`를 사용하여 지시해야 합니다.
    > - **누가 하는가?**
    >     - **컴파일러:** 컴파일 시점에 개발자가 명시적으로 캐스팅을 요청했는지, 그리고 문법적으로 캐스팅이 가능한지(예: 숫자 타입을 문자열 타입으로 강제 캐스팅할 수는 없음)를 검사합니다. 만약 문법적으로 불가능하면 컴파일 에러를 발생시킵니다.
    >     - **JVM:** **런타임 시점에 실제 캐스팅을 수행**합니다. 특히 참조 타입의 캐스팅(예: 부모 클래스 참조를 자식 클래스 타입으로 캐스팅)의 경우, JVM은 런타임에 실제 객체의 타입이 캐스팅하려는 타입과 호환되는지(즉, `instanceof` 검사와 유사하게) 확인합니다. 만약 호환되지 않으면 `ClassCastException` 런타임 예외를 발생시킵니다. 기본형의 캐스팅(예: `long`을 `int`로)은 JVM이 해당 바이트코드 명령을 실행하여 값을 자릅니다(truncation).
    > - **어떻게?** 컴파일러는 개발자가 지정한 캐스팅 연산자를 바이트코드 내의 적절한 변환 명령어로 변환합니다. JVM은 이 명령어를 따라 변환을 시도하며, 참조 타입의 경우 런타임 타입 체크를 추가로 수행합니다.
    - **사용자 정의 데이터 타입**
    - **클래스 타입**
    - **인터페이스 타입**
    - **Enum**

### 자바 기초 프로그래밍

- **Java 메인 클래스** : 메인(`main`) 메소드를 가지고 있는 클래스로, 메인 클래스부터 프로그램이 시작됨. 많은 클래스 중에 메인 클래스는 딱 하나만 존재한다.
- 자바에서는 클래스명을 표기할 때 **파스칼 표기법(Pascal)**
    - 첫 글자를 포함하여 모든 단어의 첫 글자가 대문자입니다.
    - 단어와 단어 사이에 공백이나 특수 문자(언더스코어 등)를 사용하지 않습니다.
- 변수나 메소드는 **카멜 표기법(camel case)**
    - 첫 글자는 항상 소문자입니다.
    - 단어와 단어 사이에 공백이나 특수 문자(언더스코어 등)를 사용하지 않습니다.