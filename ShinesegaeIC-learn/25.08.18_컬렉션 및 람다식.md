# 25.08.18.(월) 컬렉션 및 람다식

### Map<K, V>

- 키셋을 얻어서 반복해서 키와 값을 읽고 싶을 떄
    - `Set<String> keyset = map.keySet();`
    - `Iterator<String> iterator = keyset.iterator(); // 키를 반복하기 위해서 반복자 생성`
- 엔트리 Set 컬렉션을 얻고 반복해서 키와 값을 얻는 방법
    - `Set<Map.Entry<String,Integer>> entrySet = map.entrySet();`

### Properties

- 키와 값이 String으로 된 Map 객체
- 데이터베이스 등의 환경설정 파일로 활용된다. Ex. databaseConfig.properties
    
    ```java
    driver = oracle.jdbc.OracleDriver
    url = jdbc:oracle:thin:@localhost:1521:orcl
    user = root
    password = root1234
    ```
    

```java
// Properties 객체 생성
        Properties p = new Properties();

        p.load(PropertiesEx.class.getResourceAsStream("database.properties"));

        String driver  = p.getProperty("driver");
```

### 트리(Tree)

Node(노드 ,데이터저장), Branch (가지, 브랜치)를 이용해서, 사이클을 이루지 않도록 구성된 데이터 구조

1. Node : 트리에서 데이터를 저장하는 기본 요소 (데이터와 다른 연결된 노드에 대한 Branch 정보 포함)
2. RootNode : 트리에서 맨 위의 시작 노드
3. Level(Depth) : 최상위 노드를 Level 0으로 하였을 때, 하위 Branch로 연결된 노드의 깊이를 나타냄
4. Parent Node (부모 노드) : 어떤 노드의 위 level 노드
5. Child Node (자식 노드) : 
6. Leaf Node(Terminal Node) : Child Node가 하나도 없는 노드
7. Sibling(Brother Node) : 형제 노드, 동일한 Parent Node를 가진 노드

이진트리와 이진 탐색 트리 (Binary Search Tree)

이진트리 : 노드의 최대 Branch가 2인 트리

이진탐색트리 (BST) : 이진 트리에 왼쪽 노드는 해당 노드보다 작은 값, 오른쪽 노드에는 해당 노드보다 큰 값을 배치하는 조건이 있는 트리

주요 용도 : 데이터 검색(탐색)

장점 : 탐색 속도를 개선할 수 있음

단점 : 

### Comparable<E> 인터페이스

하나의 메소드로 `int compareTo(T o)` 를 가지고 있다.

compareTo 메소드를 오버라이딩해서 사용한다. 오름차순인 경우 현재 인스턴스의 값이 비교할 인스턴스의 값보다 작게. 즉, 뺄셈 연산을 통한 값을 리턴한다.

```java
public class Fruit implements Comparable<Fruit> {
    private String name;
    private int cost;
    public Fruit(String name, int cost) {
        this.name = name;
        this.cost = cost;
    }
    
    @Override
    public int compareTo(Fruit o) {
        return this.cost - o.cost;
    }
    // 
    
}
```

### Comparator<T>

기준을 매번 바꿔야 하는 요구사항에 따라 구현해야 하는 경우에 많이 쓰인다.

별도의 정렬 기준 클래스를 구현하여 사용한다. 사용 시 구현한 클래스의 인스턴스 생성문을 인자로 전달하면 된다.

`int compare(T o1, T o2)` 

```java
import java.util.Comparator;

public class FruitComparator implements Comparator<Fruit> {

    @Override
    public int compare(Fruit o1, Fruit o2) {
        return o1.price - o2.price;
    }
}
```

```java
public class ComparatorEx {
    public static void main(String[] args) {
        // 과일 가게에서 과일을 관리할 때의 기준(FruitComparator)으로 정렬하여 관리하겠다.
        TreeSet<Fruit> fruits = new TreeSet<Fruit>(new FruitComparator());

        fruits.add(new Fruit("Apple", 100));
        fruits.add(new Fruit("Banana", 50));
        fruits.add(new Fruit("PineApple", 200));

        for (Fruit fruit : fruits) {
            System.out.println(fruit.name + " " + fruit.price);
        }

    }
}
```

### 수정할 수 없는 컬렉션

요소를 추가, 삭제할 수 없는 컬렉션

컬렉션 생성 시 저장된 요소를 변경하고 싶지 않을 때

정적 메소드 `of()` 로 생성한다.

`List<E> immList = List.of(elements...);`

`Set<E> immSet = Set.of(elements...);`

`Map<E> immMap = Map.of(K keys..., V values...);`

기존의 컬렉션을 패킹해서 별도로 보관하고 싶을 때 사용한다.
```java
public class immutableEx {
    public static void main(String[] args) {
        //List 불변 컬렉션 생성 -> 정적 메소드 of 를 사용한다.
        List<String> list = List.of("apple", "banana", "orange");

//        list.add("pineapple"); => UnsupportedOperationException raise
        for (String fruit : list) {
            System.out.print(fruit+ " ");
        }
        System.out.println();
        Map<String, Integer> map = Map.of("apple", 10000, "banana", 2500, "orange", 3000);
        for (String s : map.keySet()) {
            System.out.print(s + " " + map.get(s) + " ");
        }

    }
}

```