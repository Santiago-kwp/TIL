# 25.08.14.(목) 컬렉션

### Vector

- 동기화된 메소드로 구성되어 있어 멀티 스레드가 동시에 Vector() 메소드를 실행할 수 없음.
- 멀티 스레드 환경에서는 안전하게 객체를 추가 또는 삭제할 수 있음.

### `ArrayList`와의 비교

`Vector`는 `ArrayList`와 내부 구조가 매우 유사합니다. 하지만 결정적인 차이가 있습니다.

- **스레드 안전성:** `Vector`는 스레드 안전하지만, `ArrayList`는 그렇지 않습니다.
- **성능:** `ArrayList`는 동기화 오버헤드가 없어 단일 스레드 환경에서 `Vector`보다 훨씬 빠릅니다.
- **용량 증가:** `Vector`는 기본적으로 용량이 2배로 늘어나지만, `ArrayList`는 50%만 늘어납니다.

오늘날에는 대부분의 상황에서 `Vector` 대신 **`ArrayList`**를 사용하고, 멀티스레드 환경이 필요할 경우 `Collections.synchronizedList(new ArrayList<>())` 또는 `CopyOnWriteArrayList`와 같은 **명시적인 동기화 컬렉션**을 사용하는 것이 권장됨.

### LinkedList

- 인접 객체를 체인처럼 연결해서 관리, 객체 삭제와 삽입이 빈번한 곳에서 ArrayList보다 유리
- 배열은 순차적으로 연결된 공간에 데이터를 나열하는 데이터구조
- 떨어진 곳에 존재하는 데이터를 화살표(포인터)를 연결해서 관리하는 데이터 구조

기본 구조와 용어

- 노드(node) → 데이터 저장 단위 (데이터 값, 포인터)로 구성
- 포인터(pointer) : 각 노드 안에서, 다음이나 이전의 노드와의 연결 정보를 가지고 있는 공간

---

### `ArrayList` vs `LinkedList` CRUD 성능 비교

| 연산 | `ArrayList` (배열 기반) | `LinkedList` (이중 연결 리스트 기반) | 설명 |
| --- | --- | --- | --- |
| **Create**(추가) | `add(E)`: O(1) (평균)<br> `add(index, E)`: O(n) | `add(E)`: O(1)<br> `add(index, E)`: O(n) | `ArrayList`는 끝에 추가할 때 배열의 크기 확장 비용이 발생할 수 있지만 평균적으로 O(1)입니다. `LinkedList`는 끝 노드를 바로 참조할 수 있어 항상 O(1)입니다. 중간에 삽입할 때는 둘 다 탐색 시간이 필요합니다. |
| **Read**(조회) | `get(index)`: O(1) | `get(index)`: O(n) | `ArrayList`는 인덱스를 통해 원소에 직접 접근할 수 있어 매우 빠릅니다. `LinkedList`는 원하는 인덱스까지 노드를 순차적으로 탐색해야 하므로 느립니다. |
| **Update**(수정) | `set(index, E)`: O(1) | `set(index, E)`: O(n) | `ArrayList`는 인덱스를 통해 직접 접근하여 값을 수정할 수 있습니다. `LinkedList`는 조회와 마찬가지로 해당 인덱스까지 탐색해야 하므로 느립니다. |
| **Delete**(삭제) | `remove(index)`: O(n) | `remove(index)`: O(n) | `ArrayList`는 원소 삭제 후 뒤에 있는 원소들을 한 칸씩 당겨와야 합니다. `LinkedList`는 삭제할 노드의 앞뒤 노드 연결만 수정하면 되지만, 삭제할 노드를 찾는 과정이 O(n)이므로 전체 성능은 O(n)입니다. |

---

### 요약 및 선택 가이드

- **`ArrayList`는 조회(Read) 연산이 빈번할 때 유리합니다.** 인덱스를 통한 직접 접근이 가능하기 때문입니다. 배열 기반이므로 메모리 사용량이 `LinkedList`보다 적은 경향이 있습니다.
- **`LinkedList`는 데이터의 추가/삭제가 빈번할 때 유리합니다.** 특히 리스트의 양 끝에서 데이터를 추가하거나 삭제할 때 O(1)의 성능을 보입니다. 하지만 인덱스를 통한 접근이 비효율적이므로 특정 위치의 원소를 조회하거나 수정하는 작업이 잦다면 불리합니다.

### Set

- HashSet 클래스를 가장 많이 사용한다.
- 동일한 객체(동등객체)는 저장하지 않는다. → 동등객체를 판단하는  방법을 알아야 한다.
    - hashCode() 판별 (같음) → equals() 판별 (다름)→ 저장하지 않는다
    - hashCode() 판별 (다름) → 저장하지 않는다
- Set 컬렉션은 인덱스로 객체를 검색하여 가져오는 메소드가 없다. 객체를 한개씩 반복해서 가져와야 하는데 for 문을 이용하는 방법과 iterator 방법 2가지가 있다.

```java
Set<E> set = new HashSet<>();
for (E e : set) {}

Set<E> set = new HashSet<>();
Iterator<E> iterator = set.iterator(); // 개발자 선호 

while(iterator.hasNext()) {
		E e = iterator.next(); // 객체를 꺼내온다
		iterator.remove(); // 객체 삭제
}
```

- **`Iterator`를 직접 사용하는 경우**: 반복 중에 **요소를 삭제**해야 할 때 유용합니다. `iterator.remove()` 메서드를 호출하여 안전하게 컬렉션의 요소를 삭제할 수 있습니다.
- **향상된 `for` 루프를 사용하는 경우**: **읽기 전용**으로 컬렉션을 순회할 때 코드를 더 간결하고 가독성 높게 작성할 수 있습니다.