# 25.08.08.(금) 인터페이스 및 다형성

수업 외

- 회사 추천 : 제니퍼 소프트 (신입은 안뽑음..) (매출 100억에 순이익이 40억…??? 사원수는 22명??? 그냥 못들어간다고 생각하는게 속 편하겠다. 참고만 하자)
- 내가 생각하는 좋은 회사의 조건은 어떻게 되는지 생각해보기

## 추상 클래스

> 클래스들을 모아서 공통적으로 규칙을 적용하기 위함임. 규칙을 만드는 것은 애플리케이션을 잘 만들기 위함이고, 설계 원칙을 적용하는 것임. 사용자가 원하는 쉽고 반응이 좋은, 정확한 서비스를 만들기 위해서 클래스들 간 규약을 정하는 설계가 필요하기 때문임.
> 

추상 메소드와 재정의

- 메소드의 시그니처는 있는데, 구현부(`{}`)가 없음.
- 부모 클래스에서 자식 클래스에게 강요하는 것이라고 생각할 수 있음. 너가 만약 나를 상속하려고 한다면 이걸 만들어줘야 해.
- 모든 기능인 메소드를 클래스에 다 때려박기보다는 자바는 데이터에 대한 부분을 모아서 클래스에 정의하고, 기능들은 인터페이스로 묶음. 왜냐면 자바는 단일상속 원칙이므로

## 인터페이스

> 두 장치(서로 다른 객체)를 연결하는 접속(연결하는 역할) 도구
서로 다른 객체를 연결하는 역할을 하는 객체
> 

### 인터페이스 개념

- 추상 클래스와 마찬가지로 인터페이스는 그 자체의 객체를 만들 수 없음

### 인터페이스 사용 이유

- 완전한 추상화를 구현
- **SOLID 원칙 (모든 객체 지향 프로그래밍언어를 통한 프로그래밍에 적용되는 원칙으로 반드시 이해 및 숙지 해야 함)**
    - **S**ingle **R**esponsibility **P**rinciple(SRP) : 단일 책임 원칙 - 객체는 오직 하나의 책임을 가져야 한다.
        - 클래스의 목적을 명확히 하자
        - 귀찮다고 계산 클래스를 통해 GUI를 가지는 계산기 프로그램을 만든다면, GUI를 수정하기 위해 별 상관도 없어 보이는 계산  클래스를 고쳐야 한다. → 유지보수가 힘들어지며, 작성한 본인도 나중에는 정확히 뭐하는 클래스인지 설명할 수 없는 스파게티 코드가 됨.
    - Open - Closed Principle (OCP) : 개방 폐쇄 원칙 - 객체는 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야 한다.
        - 개체의 확장은 허용하고, 변경은 피해야 한다.
    - Liskov Substitution Principle (LSP) : 리스코프 치환 원칙 - 자식 클래스는 언제나 부모 클래스를 대체할 수 있다는 원칙. 즉, 부모 클래스 대신 자식 클래스를 부모 클래스로 바꿔도 잘 동작해야 된다.
        - 마우스의 좌클릭, 우클릭이 기본 동작인데 펜마우스라는 것이 나와서 옆쪽 버튼을 사용한다면, 사용자는 평소 익숙한 버튼을 누를 수 없어서 이상을 호소할 것임.
    - Interface Segregation Principle (ISP) : 인터페이스 분리 원칙 - 인터페이스를 작게 나누어 만들자
    - Dependency Inversion Principle (DIP) : 의존성 역전 원칙 - 추상성이 높고 안정적인 고수준의 클래스는 구체적이고 불안정한 저수준의 클래스에 의존해서는 안된다.
        - 커피숍 프렌차이즈에서 음료 제조를 담당하는 바리스타라는 고수준 클래스가 특정 브랜드의 커피 머신 - 저수준 구현체 - 의 종류에 따라 바뀐다고 가정해보자. 만약 해당 커피 머신에 문제가 발생하거나, 더 나은 신형의 커피 머신으로 교체하는 상황이 오면, 고수준 클래스 역시 수정해야 하는 불상사가 발생한다.
- loose coupling (느슨한 결합) 관계를 위해 사용한다.
    - 부품 교체를 편하게 하기 위해서
- 다중 상속을 구현할 수 있다.

![image.png](attachment:30fb2977-0991-4a47-a86b-360f76cf9ead:image.png)

- 육각형의 객체는 내부 육각형은 클래스의 은닉화된 필드(데이터)를 의미하며, 이 데이터에 접근하기 위해 바깥 육각형은 기능(메소드)을 의미함.
- 각 클래스는 인터페이스를 통해서만 요청과 응답을 받음

```java
public class User {
    public static void main(String[] args) {
        // 사용자가 리모콘 인터페이스를 통해서 TV 객체에 일을 시킨다(동작 시킨다).
        RemoteControl rc = new Television();
        rc.turnOn();
        rc.turnOff();
}
```

### 인터페이스의 사용

- 인터페이스도 하나의 타입이므로 변수의 타입으로 사용할 수 있다.
- 인터페이스는 참조 타입이다.
- 인터페이스 변수에는 객체의 참조값을 저장할 수 있다.
- null 초기값 가능

### 상수 필드

- 인터페이스는 `public static final` 특성을 갖는 불변의 상수 필드를 멤버로 가질 수 있음.
- 상수명은 대문자로 작성하되, 서로 다른 단어로 구성되어 있으면 `_` 로 연결하는 스네이크 방식으로 정의 (Ex. `MAX_VALUE = 10`)

### default 메소드

- 인터페이스에는 완전한 실행 코드를 가지는 디폴트 메소드를 선언할 수 있음.

### 정적 (static) 메소드

- 구현 객체가 없어도 인터페이스만으로 호출할 수 있음.
- 선언 시 `public` 을 생략하더라도 자동으로 컴파일 과정에서 붙음
- static 필드, private static 메서드 접근 및 호출 가능
- 인스턴스 메소드, 디폴트 메소드, private 메소드 호출 불가

### private 메소드

- 인터페이스의 구성 요소인 상수 필드, 추상 메소드, 디폴트 메소드, 정적 메소드는 모두 `public` 접근 제한자를 가져야 함.
- 인터페이스의 `public`의 의미는 외부에서 누구나 호출하거나 접근할 수 있다는 의미
- 인터페이스의 외부에서 접근할 수 없는 `private` 메소드 선언 가능 → 왜 필요할까? → 디폴트 메소드 내 공통 기능이 필요할 때 묶어서 활용 + 정적 메소드 내 공통 기능이 필요할 때 묶어서 활용하기 위함임.
    - `private` 메소드 : 구현 객체가 필요한 메소드 → 디폴트 메소드 안에서만 호출이 가능
    - `private static` 메소드 : 구현 객체가 필요 없는 메소드

```java
package javabasic_02.day12;

public interface Service {
    // 디폴트 메소드
    default void defaultMethod1() {
        System.out.println("default1()");
        defaultCommon();
    }

    default void defaultMethod2() {
        System.out.println("default2()");
        defaultCommon();
    }

    // private 메소드
    private void defaultCommon() {
        System.out.println("defaultMethod의 중복코드 A");
        System.out.println("defaultMethod의 중복코드 B");
    }

    // static(정적) 메소드
    static void staticMethod1(){
        System.out.println("staticMethod1() 코드");
        staticCommon();
    }

    static void staticMethod2(){
        System.out.println("staticMethod2() 코드");
        staticCommon();
    }

    // private static 메소드
    private static void staticCommon() {
        System.out.println("staticMethod 중복코드 A");
        System.out.println("staticMethod 중복코드 B");
    }
}

package javabasic_02.day12;

public class User1 {

    public static void main(String[] args) {
        Service service = new ServiceImpl(); // ServiceImpl2 로 바꿔도 전혀 문제가 없음 : Loose Coupling임

        // 디폴트 메소드 호출
        service.defaultMethod1();
        service.defaultMethod2();

        // 정적 메소드 호출
        Service.staticMethod1();
        Service.staticMethod2();

    }
}

```

### 다중 인터페이스

인터페이스 : 기능에 대한 표준 스펙을 정의하는 데이터 타입

- 구현 객체는 여러개의 인터페이스를 implements (기능을 나에게 맞추어서 재정의 해야만 한다.)
- 보통 클래스는 명사, 인터페이스는 형용사, 메소드는 동사를 많이 선택한다.
- 아래와 같이 다중 인터페이스를 구현한 `rc`는 스마트 텔레비전 리모콘 객체를 구현
    - 스마트 텔레비전은 검색을 할 수 있게 객체로 구현 : `searchable`

```java
package javabasic_02.day12.afternoon;

import java.util.ArrayList;
import java.util.List;

public class User1 {
    public static void main(String[] args) {
        RemoteControl rc = new SmartTelevision();  // 참조 인터페이스의 구현 객체
        List<Integer> list = new ArrayList<>();
        rc.turnOn();
        rc.turnOff();
        Searchable searchable = new SmartTelevision();
        searchable.search("www.youtube.com");

    }
}

```

### 인터페이스의 상속

인터페이스도 다른 인터페이스를 상속(extends) 할 수 있다. 클래스와 달리 다중 상속을 허용한다.

`public interface 자식 인터페이스 extends 부모1 인터페이스, 부모2 인터페이스, ...`

```java
package javabasic_02.day12.afternoon.sec02;

public class User {

    public static void main(String[] args) {
        InterfaceImpl impl = new InterfaceImpl();

        InterfaceA ia = impl;
        ia.methodA();

        InterfaceB ib = impl;
        ib.methodB();

        InterfaceC ic = impl;
        ic.methodA();
        ic.methodB();
        ic.methodC();
    }
}

```

- 회원등급 별 구독 서비스 제한하는 것처럼 `ic` 는 세 개의 메소드를 쓸 수 있지만, `ia` 와 `ib` 는 각각 한 개의 메소드만 쓸 수 있음. → 쓰도록 제한할 수 있음.

### Quiz - 클래스 개념 문제

1. 자바의 상속에 대한 설명 중 틀린 것은 무엇입니까?
    1. 자바는 다중 상속을 허용한다.(X)
    2. 부모의 메소드를 자식 클래스에서 재정의할 수 있다.(O)
    3. 부모의 private 접근 제한을 갖는 필드와 메소드는 상속의 대상이 아니다.
    4. final 클래스는 상속할 수 없고, final 메소드는 오버라이딩할 수 없다.
2. 클래스 타입 변환에 대한 설명 중 틀린 것은 무엇입니까?
    1. 자식 객체는 부모 타입으로 자동 타입 변환된다. (O)
    2. 부모 객체는 어떤 자식 타입으로도 강제 타입 변환된다. (X?)
    3. 자동 타입 변환을 이용해서 필드와 매개변수의 다형성을 구현한다. (O)
    4. 강제 타입 변환 전에 instanceof 연산자로 변환 가능한지 검사하는 것이 좋다. (O)
3. final 키워드에 대한 설명으로 틀린 것은 무엇입니까?
    1. final 클래스는 부모 클래스로 사용할 수 있다. (X)
    2. final 필드는 초기화된 후에는 변경할 수 없다.
    3. final 메소드는 재정의할 수 없다.
    4. static final 필드는 상수를 말한다.
4. 오버라이딩에 대한 설명으로 틀린 것은 무엇입니까?
    1. 부모 메소드의 시그니처(리턴 타입, 메소드명, 매개변수)와 동일해야 한다.
    2. 부모 메소드보다 좁은 접근 제한자를 붙일 수 없다 (예: 부모는 public → 자식은 private)
    3. @Override 어노테이션을 사용하면 재정의가 확실한지 컴파일러가 검증한다.
    4. protected 접근 제한을 갖는 메소드는 다른 패키지의 자식 클래스에서 재정의할 수 없다.(X)
5. 추상 클래스에 대한 설명으로 틀린 것은 무엇입니까?
    1. 직접 객체를 생성할 수 없고, 상속만 할 수 있다.
    2. 추상 메소드를 반드시 가져야 한다. (X)
    3. 추상 메소드는 자식 클래스에서 재정의(오버라이딩) 할 수 있다.
    4. 추상 메소드를 재정의하지 않으면 자식 클래스도 추상 클래스가 되어야 한다.
6. Parent 클래스를 상속해서 Child 클래스를 다음과 같이 작성했는데, Child 생성자에서 컴파일 에러가 발생했습니다. 그 이유와 해결 방법을 설명해보세요.

![image.png](attachment:475662a1-6040-4941-9d87-7bf59acf2538:image.png)

- Child 생성자의 매개변수로 String name과 int studentNo를 인자로 받아서 인스턴스를 생성하려면, 부모의 생성자 호출이 선행되어야 하므로 [this.name](http://this.name) = name 대신에 super(name)을 통해서 부모의 생성자를 호출하고, 그 뒤에 this.studentNo = studentNo; 를 붙여야 함.

```java
public class Child extends Parent{
    public int studentNo;

    public Child(String name, int studentNo) {
        super(name);
        this.studentNo = studentNo;
    }
}
```

1. Parent 클래스를 상속받아 Child 클래스를 다음과 같이 작성했습니다. ChildExample 클래스를 실행했을 때 호출되는 각 클래스의 생성자의 순서를 생각하면서 출력 결과를 작성해보세요.

```java
Child child = new Child();
------- 실행 순서 및 출력 결과 -------
Child() 실행 -> super() 실행 -> this("대한민국") 실행
-> "Parent(String nation) call" 프롬프트 출력
-> "Parent() call" 프롬프트 출력
-> this("홍길동") 실행
-> "Child(String name) call" 프롬프트 출력
-> "Child() call" 프롬프트 출력
```

1. Tire 클래스를 상속받아 SnowTire 클래스를 다음과 같이 작성했습니다. SnowTireExample 클래스를 실행했을 때 출력 결과를 작성해보세요.

```java
package javabasic_02.day12.afternoon.BasicPractice.Prob8;

public class SnowTireExample {
    public static void main(String[] args) {
        SnowTire snowTire = new SnowTire();
        Tire tire = snowTire;

        snowTire.run(); // 스노우 타이어가 굴러갑니다.
        tire.run();     // 스노우 타이어가 굴러갑니다. ~ 메소드 오버라이딩
    }
}

```

1. A, B, C, D, E, F 클래스가 다음과 같이 상속 관계에 있을 때 다음 빈칸에 들어올 수 없는 코드를 선택하세요.

![image.png](attachment:455993f6-6b24-4505-991a-fe2037195151:image.png)

- 정답은 : 2번 `(B) new A()` 는 강제 형변환될 수 없음. 부모 클래스인 A 인스턴스는 자식 클래스인 B로 강제 형변환될 수 없다. 자식 클래스에서 새로 정의한 메소드나 필드가 없으므로

1. Computer 클래스에서 컴파일 에러가 발생했습니다. 그 이유를 설명해보세요.

![image.png](attachment:5e56addc-c095-4a78-9e94-87bd7492baf8:image.png)

- 추상 클래스인 Machine을 상속하려면 반드시 추상 메소드인 work()의 구현부가 존재해야 함.
1. MainActivity의 onCreate()를 실행할 때 Activity의 onCreate()도 실행시키고 싶습니다. 밑줄에 들어갈 코드를 작성해보세요.

![image.png](attachment:14b0b032-312a-42fd-a178-424a6c8e8915:image.png)

- `super`

1. 다음과 같이 Example 클래스에서 action() 메소드를 호출할 때 매개값이 C 객체일 경우에만 method2()가 호출되도록 밑줄에 들어갈 코드를 작성해보세요.

![image.png](attachment:d18758ff-47b0-4142-9923-f9477da36043:image.png)

- `a instanceof C c`

### Quiz - 인터페이스 개념 문제

1. 인터페이스에 대한 설명으로 틀린 것은 무엇입니까?
    1. 인터페이스로 객체(인스턴스)를 생성할 수 있다.(X)
    2. 인터페이스는 다형성의 주된 기술로 사용된다.
    3. 인터페이스를 구현한 객체는 인터페이스로 동일하게 사용할 수 있다. (O)
        1. 인터페이스는 여러 객체가 공통적으로 가져야 할 **기능의 규격(청사진)**을 정의하는 계약서와 같습니다. 여러 클래스가 이 인터페이스를 `implements`하면, 그 클래스들은 모두 인터페이스가 정의한 메소드를 반드시 구현하게 됩니다. 결과적으로, 이 인터페이스를 구현한 모든 객체들은 마치 같은 타입인 것처럼 다뤄질 수 있습니다.
        2. `sound1` 변수는 `Dog` 객체를, `sound2` 변수는 `Cat` 객체를 가리키지만, 둘 다 `Sound` 인터페이스의 메소드인 `makeSound()`를 호출할 수 있습니다. 이것이 바로 "인터페이스를 구현한 객체는 인터페이스로 동일하게 사용할 수 있다"는 문장의 의미입니다. 즉, 어떤 객체인지에 상관없이 **인터페이스가 정의한 기능을 통일된 방식으로 호출**할 수 있다는 뜻입니다.
    4. 인터페이스를 사용함으로써 객체 교체가 쉬워진다.

1. 인터페이스의 구성 멤버에 대한 설명으로 틀린 것은 무엇입니까?
    1. 인터페이스는 인스턴트 필드가 없고 상수를 멤버로 가진다.
    2. 추상 메소드는 구현 클래스가 재정의해야 하는 멤버다.
    3. 디폴트 메소드는 구현 클래스에서 재정의할 수 없다(X)
    4. 정적 멤버는 구현 객체가 없어도 사용할 수 있는 멤버다.

1. 인터페이스 다형성에 대한 설명으로 틀린 것은 무엇입니까?
    1. 필드가 인터페이스 타입일 경우 다양한 구현 객체를 대입할 수 있다.
    2. 매개변수가 인터페이스 타입일 경우 다양한 구현 객체를 대입할 수 있다.
    3. 배열이 인터페이스 타입일 경우 다양한 구현 객체를 저장할 수 있다.
    4. 구현 객체를 인터페이스 타입으로 변환하려면 강제 타입 변환을 해야 한다. (X)

1. 인터페이스 A를 B와 C가 구현하고 B를 상속해서 D 클래스를, C를 상속해서 E 클래스를 만들었습니다. 다음 빈칸에 들어올 수 있는 것을 모두 선택하세요.

![image.png](attachment:c6987a7c-f391-4d66-b898-0c13286df6a4:image.png)

- 정답 : 1, 2, 3, 4 전부

1. TV 클래스를 실행했을 때 “TV를 켰습니다.” 라고 출력되도록 밑줄과 박스에 들어갈 코드를 작성해보세요.

![image.png](attachment:b0809cfb-02df-4fc1-8f32-15de70a48009:image.png)

```java
public class TV implements Remocon {
		@Override
		public void powerOn() {
				System.out.println("TV를 켰습니다.");
		}
```

1. Soundable 인터페이스는 다음과 같은 `sound()` 추상 메소드를 가지고 있습니다. SoundableExample 클래스의 `printSound()` 메소드는 매개변수 타입으로 Soundable 인터페이스를 가집니다. `printSound()`를 호출할 때 Cat  과 Dog 객체를 주고 실행하면 각각 “야옹” 과 “멍멍”이 출력되도록 Cat과 Dog 클래스를 작성해보세요.

![image.png](attachment:b03b58df-bfd9-416a-ab95-e20d021e5287:image.png)

```java
public class Dog implements Soundable{

    @Override
    public String sound() {
        return "멍멍";
    }
}

public class Cat implements Soundable{
    @Override
    public String sound() {
        return "야옹";
    }
}

```

1. DaoExample 클래스의 main() 메소드에서 dbWork() 메소드를 호출할 때 OracleDao와 MysqlDao 객체를 매개값으로 주고 호출했습니다. dbWork() 메소드는 두 객체를 모두 매개값으로 받기 위해 DataAccessObject 타입의 매개변수를 가지고 있습니다. 실행 결과를 보고 DataAccessObject 인터페이스와 OracleDao, MySqlDao 구현 클래스를 각각 작성해보세요.

```java
public interface DataAccessObject {
    public void select();
    public void insert();
    public void update();
    public void delete();
}

public class MySqlDao implements DataAccessObject{

    @Override
    public void select() {
        System.out.println("MySql DB에서 검색");
    }

    @Override
    public void insert() {
        System.out.println("MySql DB에 삽입");
    }

    @Override
    public void update() {
        System.out.println("MySql DB를 수정");
    }

    @Override
    public void delete() {
        System.out.println("MySql DB에서 삭제");
    }
}

package javabasic_02.day12.afternoon.BasicPractice.Prob7Interface;

public class OracleDao implements DataAccessObject{

    @Override
    public void select() {
        System.out.println("Oracle DB에서 검색");
    }

    @Override
    public void insert() {
        System.out.println("Oracle DB에 삽입");
    }

    @Override
    public void update() {
        System.out.println("Oracle DB를 수정");
    }

    @Override
    public void delete() {
        System.out.println("Oracle DB에서 삭제");
    }
}

```

1. 다음과 같이 인터페이스와 클래스가 선언되어 있습니다. action() 메소드를 호출할 때 매개값이 C 객체일 경우에만 method2()가 호출되도록 밑줄에 들어갈 코드를 작성해보세요.
    
    ![image.png](attachment:e19a6a49-1234-47d3-b125-5f6d3b670433:image.png)
    

정답 : `a instanceof C c`