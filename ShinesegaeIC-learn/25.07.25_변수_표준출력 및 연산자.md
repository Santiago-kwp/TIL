# 25.07.25.(금) 변수, 표준 출력 및 연산자

### 변수 사용 Scope의 이해

- 넓은 범위에서 선언한 변수는 좁은 범위에서 조회, 사용할 수 있음.

### printf

![image.png](attachment:fc4df506-5e29-4354-b9ab-a2bf28d78639:image.png)

```java
System.out.printf("과목명: %3$s 이름: %2$s 학번: %3$s\n","자바","서유미","1234");
// 실행 결과
과목명: 1234 이름: 서유미 학번: 1234
```

- `값의 순번$` (ex.1$) 로 인덱싱 가능
- IntelliJ에서 `souf` 하면 바로 `System.out.printf()` 코드 짜줌
- flag에 `-`를 붙이면 뒤에다가 빈 공간 만듦, 없으면 앞에 공간을 만듦. `0` 을 넣으면 0으로 채움.

```java
				//  정수 ___123을 prinf()로 출력하자.
        System.out.printf("%6d\n",123);

        // 정수 123___을 printf()로 출력하자.
        System.out.printf("%-6d\n",123);

        // 정수 000123을 printf()로 출력하자.
        System.out.printf("%06d\n",123);

        // 정수 7자리 + 소수점 + 소수2자리 왼쪽 빈자리 공백 ____123.45
        System.out.printf("%10.2f\n",123.45);

        // 정수 7자리 + 소수점 + 소수2자리 왼쪽 빈자리 0
        System.out.printf("%010.2f\n",123.45);

        // 문자열은 %s 포맷
        System.out.printf("%s\n","abc");
        // ___abc출력
        System.out.printf("%6s\n","abc");

        // 특수 문자 \t, \n, %%
        System.out.printf("소금물의 농도 %% %1$d\n",35);

```

### 연산자

- 부호 연산자(`+/-`)
- 증감 연산자(`++`/ `—` , 전치, 후치 연산)
- 산술 연산자(`+-/*%`)
- 오버플로우/언더플로우
- 논리연산자 (논리곱 : `&&`, 논리합 : `||`, 논리부정 : `!`, 배타적 논리합(`^`))
- 비트 연산자 (비트 논리 곱 : `&`, 논리 합 : `|`, 논리부정 : `~`, 배타적 논리합(`^`), 비트 왼쪽 쉬프트 : `<<`, 비트 오른쪽 쉬프트: `>>`, `>>>` : 정수 a의 각 비트를 b만큼 오른쪽으로 이동하고 왼쪽 빈자리는 0으로 채움)
    - 부호 없는 오른쪽 시프트 : >>> 의 존재 이유 : 숫자의 원래 부호와 상관없이 0으로 채우기 때문에 "zero-fill right shift"라고도 불림.
    - 자바에서 오른쪽 시프트 연산자가 `>>` 와 `>>>` 두 개로 나뉘는 이유는 **음수를 처리하는 방식의 차이** 때문임.
    
    자바의 모든 정수 타입(byte, short, int, long)은 **부호 있는 정수(signed integer)**로 표현됩니다. 컴퓨터는 음수를 **2의 보수(two's complement)** 방식으로 표현하는데, 이 방식에서는 가장 왼쪽 비트(최상위 비트, Most Significant Bit, MSB)가 숫자의 부호를 나타냅니다. 0이면 양수, 1이면 음수입니다.
    
    ### 1. `>>` (부호 있는 오른쪽 시프트, Signed Right Shift)
    
    - **설명:** 이 연산자는 비트를 오른쪽으로 이동시킬 때, **가장 왼쪽의 빈 공간을 원래 숫자의 부호 비트(MSB)로 채웁니다.** 즉, 양수이면 0으로, 음수이면 1로 채웁니다.
    - **용도:** 주로 **정수 나눗셈과 같은 산술적인 시프트**를 수행할 때 사용됩니다. `x >> n`은 x를 2^n으로 나눈 것과 같은 효과를 냅니다 (음수의 경우 소수점 이하를 버리는 방식이 다소 다를 수 있지만, 기본적으로 나눗셈의 의미를 가집니다). 숫자의 부호를 유지하면서 값을 줄이고 싶을 때 사용합니다.
    - **예시:**
        - 양수: `8 >> 2` (8을 2비트 오른쪽으로 이동)
            - 8 (10진수) = `0000 1000` (2진수)
            - `0000 1000 >> 2` = `0000 0010` (가장 왼쪽을 0으로 채움) = 2 (10진수)
        - 음수: `8 >> 2` (-8을 2비트 오른쪽으로 이동)
            - 8 (10진수, 2의 보수) = `1111 1000` (2진수)
            - `1111 1000 >> 2` = `1111 1110` (가장 왼쪽을 1로 채움, 즉 부호 비트 유지) = -2 (10진수)
    
    ### 2. `>>>` (부호 없는 오른쪽 시프트, Unsigned Right Shift or Zero-Fill Right Shift)
    
    - **설명:** 이 연산자는 비트를 오른쪽으로 이동시킬 때, **가장 왼쪽의 빈 공간을 항상 0으로 채웁니다.** 숫자의 원래 부호와 상관없이 0으로 채우기 때문에 "zero-fill right shift"라고도 불립니다.
    - **용도:** 주로 **비트 단위 연산**에서 숫자의 부호에 관계없이 비트 패턴 자체를 이동시키고 싶을 때 사용됩니다. 특히, 특정 비트 마스크를 적용하거나, 이미지 처리, 암호화 등 비트 조작이 중요한 분야에서 유용하게 사용됩니다. 이 연산은 음수를 양수로 변환할 수 있습니다.
    - **예시:**
        - 양수: `8 >>> 2` (8을 2비트 오른쪽으로 이동)
            - 8 (10진수) = `0000 1000` (2진수)
            - `0000 1000 >>> 2` = `0000 0010` (가장 왼쪽을 0으로 채움) = 2 (10진수)
            - (양수의 경우 `>>`와 결과가 동일합니다.)
        - 음수: `8 >>> 2` (-8을 2비트 오른쪽으로 이동)
            - 8 (10진수, 2의 보수) = `1111 1000` (2진수)
            - `1111 1000 >>> 2` = `0011 1110` (가장 왼쪽을 항상 0으로 채움) = 62 (10진수)
            - (-8이 양수 62로 변환된 것을 볼 수 있습니다.)
        
        ### 왜 두 개가 필요한가?
        
        자바는 C/C++과 달리 모든 정수 타입이 부호 있는(signed) 타입입니다. C/C++에서는 `unsigned int`와 같은 부호 없는 타입을 명시적으로 선언할 수 있고, 이때 `>>` 연산자는 부호 없는 오른쪽 시프트처럼 동작합니다. 하지만 자바에서는 모든 정수가 부호를 가지고 있기 때문에, 비트 연산에서 **부호를 유지할 것인지(산술 시프트)** 또는 **부호를 무시하고 비트 패턴만 이동시킬 것인지(논리 시프트)**에 따라 두 가지 다른 연산자를 제공하는 것입니다.
        
        - `>>`: **산술적 의미**가 강하며, 2로 나누는 것과 유사한 효과를 내면서 부호를 보존합니다.
        - `>>>`: **순수한 비트 이동**에 초점을 맞추며, 비트 패턴을 '0으로 채우면서' 이동시킵니다. 이로 인해 음수가 양수로 변환될 수 있습니다.
- 대입 연산자(=), 복합 대입연산자(`+=, -=, *=, /=, %=, &=, ^=, |=, <≤, >>, >>>=`)
- 연산자 우선순위