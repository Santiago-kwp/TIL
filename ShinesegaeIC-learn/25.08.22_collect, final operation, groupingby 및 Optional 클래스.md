# 25.08.22.(금) 스트림 - collect, final operation, groupingby 및 Optional 클래스

## 스트림 요소 처리

데이터는 지나가게 두고 중간 중간 처리하여 빠르게 데이터를 서비스하기 위함. 

### 필터링

- 필터링은 요소를 걸러내는 중간 처리 기능
- 리턴 타입은 : `Stream, IntStream, LongStream, DoubleStream`
- `distinct()` 메소드 : 요소의 중복을 제거 → 상태 저장하는 거 아닌가?
    
    > A> 네, 맞습니다. `distinct()` 메서드는 내부적으로 **상태를 저장**합니다.
    `stream()`의 **무상태성(stateless)**은 모든 중간 연산이 무상태라는 의미가 아닙니다. 이는 스트림 연산의 **일반적인 특성**을 나타냅니다.
    > 
    
    **중간 연산의 종류**
    
    ---
    
    스트림의 중간 연산은 크게 두 가지로 나뉩니다.
    
    1. **무상태(Stateless) 중간 연산:**
        - 이전 요소의 상태에 영향을 받지 않고 각 요소를 독립적으로 처리합니다.
        - 예시: `filter()`, `map()`, `sorted()`
        - `map()`은 각 요소를 변환할 때 다른 요소의 정보가 필요 없습니다.
    2. **상태 저장(Stateful) 중간 연산:**
        - 연산을 수행하기 위해 **이전 요소들의 상태를 저장**해야 합니다.
        - 예시: `distinct()`, `sorted()`, `limit()`
        - `distinct()`는 중복을 제거하기 위해 이미 처리한 요소들을 **내부적으로 `Set` 같은 자료구조에 저장**합니다. 새로운 요소가 들어오면 기존에 저장된 요소와 비교하여 중복 여부를 판단합니다.
        - `sorted()`는 모든 요소를 버퍼에 저장한 후 정렬해야 하므로 상태를 가집니다.
    
    **무상태성의 진정한 의미**
    
    ---
    
    스트림 연산이 **무상태**라고 말하는 주된 이유는 다음과 같은 이점 때문입니다.
    
    - **병렬 처리 용이성:** 무상태 연산은 각 요소를 독립적으로 처리할 수 있어, 병렬 처리에 매우 유리합니다.
    - **예측 가능성:** 연산 결과가 다른 요소의 상태에 따라 달라지지 않아 코드의 예측 가능성이 높아집니다.
    
    > 하지만 `distinct()`나 `sorted()`처럼 상태를 가질 수밖에 없는 연산도 존재합니다. 이러한 연산은 내부적으로 상태를 관리하며, 병렬 처리 시에는 추가적인 오버헤드가 발생할 수 있습니다. 예를 들어, 병렬 스트림에서 `distinct()`는 각 스레드의 결과를 최종적으로 합칠 때 중복을 다시 제거하는 과정을 거칩니다.
    > 
- `filter()` 메소드 : 매개값으로 주어진 `Predicate` 가 `true`를 리턴하는 요소만 필터링
- 모든 Predicate는 매개값을 조사한 후 boolean을 리턴하는 `test()` 추상 메소드를 가지고 있음.
    - 매개변수로 람다식을 넣으면 `test()` 라는 추상 메소드를 오버라이딩하는 개념임.

### 매핑

- 스트림의 요소를 다른 요소로 변환하는 중간 처리 기능
- 매핑 메소드 : `mapXxx(), asDoubleStream(), asLongStream(), boxed()`
    - `mapToInt()`, `mapToLong()`, `mapToDouble()`, …
    - `mapToObj()` : 역직렬화 시 사용
- 매개타입인 `Function`은 함수형 인터페이스 → 모든 Function은 매개값을 리턴값으로 매핑하는 `applyXxx()` 메소드를 가짐

### flatMap 메소드

- 하나의 요소를 복수 개의 요소들로 변환한 새로운 스트림을 리턴

```java
package java_advanced_01.day19.flatMapEx;

import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

public class FlatMapEx01 {
    public static void main(String[] args) {
        List<List<String>> listOfLists = Arrays.asList(
          Arrays.asList("a"),
          Arrays.asList("b", "c"),
          Arrays.asList("d", "e"),
          Arrays.asList("f", "g"),
          Arrays.asList("h", "i")
        );

        List<String> allNames = listOfLists.stream()
                .flatMap(Collection::stream)
                .collect(Collectors.toList());

        System.out.println(allNames); // [a, b, c, d, e, f, g, h, i]
    }
}

```

### 개발자들을 괴롭히는 Null

1. Null의 정의
    1. 특정한 데이터 값이 없다. 
    2. 기본타입 X, 0 값 X, false X
    3. 참조 타입의 초기값을 null → 참조변수가 가리키고 있는 주소 값이 없다. : 아무것도 가리키고 이지 않다.
    4. 닐 (null) 포인터는 1965년 영국의 컴퓨터 과학자 **토니 호어(Tony Hoare)**가 ALGOL W 언어를 개발하면서 만들었습니다.
    5. **null의 탄생 배경 :** 토니 호어는 당시 프로그래밍 언어에서 메모리 주소를 가리키는 **포인터** 개념을 안전하게 사용하기 위해 `null`을 도입했습니다. 특정 포인터가 **아무것도 가리키고 있지 않음**을 나타내는 특별한 값으로 `null`을 만든 것입니다. 그는 이를 "존재하지 않는 것을 나타내는 유용한 방법"이라고 생각했습니다.
    - **널 포인터 역참조(Null Pointer Dereferencing):** `null` 값인 포인터에 접근하여 메모리 주소를 읽으려고 할 때 **널 포인터 예외(NullPointerException)**가 발생합니다. 이는 프로그램의 동작을 갑자기 중단시키고 예측할 수 없는 오류를 유발하는 주된 원인이 되었습니다.
    - **프로그래밍 오류:** 개발자들이 변수를 초기화하지 않은 채로 사용하거나, `null`일 가능성을 고려하지 않고 코드를 작성할 때 런타임 오류가 자주 발생했습니다.
    - `null`은 오늘날에도 여전히 많은 프로그래밍 언어에서 사용되고 있지만, `null`의 위험성을 줄이기 위한 다양한 기술(예: 자바의 `Optional`, 코틀린의 널 안정성)이 개발되고 있습니다.
2. Null과 참조형 필드와  관계
3. Null과 Static 키워드
4. Null과 instanceof
5. NullPointerException(NPE)
null을 참조하는 레퍼런스 변수로 객체의 인스턴스 메소드를 호출 시 가장 많이 발생한다.
RunTime 상황에서 NPE가 발생하기 때문에 미리미리 예방해줘야 한다.

### Optional 클래스

- `Optional, OptionalDouble, OptionalInt, OptionalLong` 클래스는 단순히 집계값만 저장. 집계값이 없으면 디폴트 값을 설정하거나 (`orElse`) 집계값을 처리하는 Consumer를 등록
- 최종 처리에서 average 사용 시 요소 없는 경우를 대비하는 방법
    - `isPresent()` 메소드가 true를 리턴할 때만 집계값을 얻는다.
    - `orElse()` 메소드로 집계값이 없을 경우를 대비해서 디폴트 값을 정해놓는다.
    - `ifPresent()` 메소드로 집계값이 있을 경우에만 동작하는 Consumer 람다식을 제공한다.

추가 읽을 필요가 있는 글

https://dzone.com/articles/using-optional-correctly-is-not-optional

https://www.latera.kr/blog/2019-07-02-effective-optional/

### 필터링한 요소 수집

- Stream의 `collect(Collector<T,A,R> collector)` 메소드는 필터링 또는 매핑된 요소들을 새로운 컬렉션에 수집하고, 이 컬렉션을 리턴
- 매개값인 `Collector` 는 어떤 요소를 어떤 컬렉션에 수집할 것인지를 결정
- 타입 파타미터의 T는 요소, A는 누적기 accumulator, 그리고 R은 요소가 저장될 컬렉션

### 요소 그룹핑

- `Collectors.groupingBy()` 메소드에서 얻은 `Collector` 를 `collect()` 메소드를 호출할 때 제공
- `groupingBy()`는 Function을 이용해서 T를 K로 매핑하고, K를 key 로 해서 List<T>를 값으로 갖는 M 컬렉션을 생성
- 

### 외부 반복자와 내부 반복자

**외부 반복자**

**외부 반복자**는 컬렉션의 요소를 순회하는 로직을 **개발자가 직접 제어**하는 방식입니다. `Iterator`나 `for-each` 루프를 사용해 각 요소를 가져오고, 그 요소에 대해 어떤 작업을 수행할지 명시합니다.

```java
List<String> names = Arrays.asList("a", "b", "c");

// 전통적인 for 루프
for (int i = 0; i < names.size(); i++) {
    System.out.print(names.get(i) + " ");
}

// Iterator 사용
Iterator<String> it = names.iterator();
while (it.hasNext()) {
    System.out.print(it.next() + " ");
}
```

위 코드들은 **개발자가 반복의 순서와 각 단계의 동작을 직접 제어**하므로 외부 반복자에 해당합니다.

**내부 반복자**

**내부 반복자**는 컬렉션의 요소를 순회하는 로직을 **라이브러리(또는 프레임워크)**에 위임하는 방식입니다. 개발자는 각 요소에 대해 **수행할 작업만 정의**하고, 반복 자체는 라이브러리가 처리합니다.

```java
List<String> names = Arrays.asList("a", "b", "c");

// Stream API의 forEach
names.stream().forEach(s -> System.out.print(s + " "));

// List 인터페이스의 forEach
names.forEach(s -> System.out.print(s + " "));
```

위 두 코드는 모두 람다 표현식으로 **'각 요소에 대해 무엇을 할지'** 만을 정의하고, 실제 반복 로직은 `Stream` 또는 `List` 인터페이스 내부에서 처리합니다. 따라서 두 코드 모두 **내부 반복자**에 속합니다.

**두 코드의 차이점**

---

두 코드 모두 내부 반복자이지만, 차이점은 **실행 환경**에 있습니다.

- `names.stream().forEach(...)`: **Stream API**를 사용합니다. 스트림은 지연 연산, 병렬 처리 등 다양한 기능을 지원합니다.
- `names.forEach(...)`: **`Iterable` 인터페이스**의 디폴트 메서드를 사용합니다. 이는 컬렉션 자체에 반복 기능을 추가한 것입니다.

`names.forEach(...)`는 스트림을 생성하지 않고 바로 순회하기 때문에, **간단한 순회**만 필요할 때는 이 코드가 **더 효율적**입니다. 반면 `names.stream().forEach(...)`는 스트림 파이프라인(`filter`, `map` 등)의 **마지막 종단 연산**으로 주로 사용됩니다.

**속도에 대한 오해와 진실**

내부 반복자와 외부 반복자의 성능은 다음과 같은 요인에 따라 달라집니다.

1. **오버헤드 (Overhead):**
    - **외부 반복자 (`for` 루프):** 가장 기본적인 형태로, 반복 로직에 대한 오버헤드가 거의 없습니다. JVM이 최적화를 매우 잘 수행하기 때문에 일반적으로 가장 빠릅니다.
    - **내부 반복자 (`forEach`):** 람다 표현식, 메서드 호출, 그리고 스트림 파이프라인(`stream().forEach()`) 생성 등의 오버헤드가 존재합니다. 이 오버헤드는 데이터 양이 적을 때는 눈에 띄게 차이를 만들 수 있습니다.
2. **병렬 처리 (Parallel Processing):**
    - 내부 반복자의 **진정한 강점**은 **병렬 처리**를 쉽게 구현할 수 있다는 점입니다.
    - `names.stream().forEach(...)`는 단순히 `names.parallelStream().forEach(...)`로 바꾸는 것만으로 멀티코어 프로세서를 활용한 병렬 처리가 가능합니다.
    - **대용량 데이터**에 대해 복잡한 연산을 수행할 때, 내부 반복자를 사용한 병렬 처리는 외부 반복자를 사용한 순차 처리보다 **압도적으로 빠른** 속도를 낼 수 있습니다.

**결론**

- **간단한 순회, 소규모 데이터:** `for` 루프와 같은 **외부 반복자**가 오버헤드 없이 가장 효율적일 수 있습니다.
- **대규모 데이터, 복잡한 연산:** 스트림 API를 사용한 **내부 반복자**는 병렬 처리를 통해 성능을 크게 향상시킬 수 있어, 외부 반복자보다 훨씬 빠를 수 있습니다.

따라서, 속도만 놓고 본다면 두 방식의 성능을 일률적으로 비교할 수 없으며, **어떤 작업을 어떤 규모의 데이터로 처리하느냐**에 따라 최적의 선택이 달라집니다.

### `stream().toList()` vs `stream().collect(Collectors.toList())`

`stream().toList()`와 `stream().collect(Collectors.toList())`는 둘 다 스트림의 요소를 `List`로 수집하는 역할을 합니다. 하지만 두 방식에는 중요한 차이점이 있습니다.

---

### 주요 차이점

1. **가변성 (Mutability):**
    - `stream().toList()`는 Java 16에서 추가되었습니다. 이 메서드는 **수정할 수 없는(unmodifiable) 리스트**를 반환합니다. 따라서 이 리스트에 요소를 추가하거나 제거하려고 하면 `UnsupportedOperationException`이 발생합니다.
    - `stream().collect(Collectors.toList())`는 Java 8부터 사용 가능했습니다. 이 메서드는 일반적으로 `ArrayList`와 같은 **수정 가능한(mutable) 리스트**를 반환합니다. 따라서 반환된 리스트의 요소를 자유롭게 수정할 수 있습니다.
2. **성능 및 효율성:**
    - `stream().toList()`는 내부적으로 스트림의 크기를 알고 있다면, 단일 패스로 최적화된 리스트를 생성할 수 있어 효율적입니다. 또한, 범용적인 가변 리스트를 만드는 오버헤드를 피할 수 있습니다.
    - `stream().collect(Collectors.toList())`는 더 범용적인 방식입니다. `ArrayList`를 생성하는 과정에서 초기 크기를 설정하거나, 요소가 추가됨에 따라 크기를 재조정하는 오버헤드가 발생할 수 있습니다. 일반적인 상황에서는 성능 차이가 미미하지만, 매우 높은 성능이 요구되는 환경에서는 차이가 있을 수 있습니다.
3. **사용 목적:**
    - 나중에 수정할 필요가 없는 단순한 리스트가 필요하다면 `stream().toList()`를 사용하는 것이 좋습니다. 코드가 간결해지고 불변성을 촉진하여 버그를 줄이는 데 도움이 됩니다.
    - 리스트를 반환받은 후 요소를 추가하거나 제거하는 등 수정이 필요하다면 `stream().collect(Collectors.toList())`를 사용해야 합니다. 이 방식이 더 유연합니다.

요약하자면, `stream().toList()`는 수정할 수 없는 리스트를 만들기 위한 현대적이고 간결하며 효율적인 방법이며, `stream().collect(Collectors.toList())`는 수정 가능한 리스트를 만들기 위한 전통적이고 유연한 방법입니다.