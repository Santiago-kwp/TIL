# 25.08.06.(수) 객체지향 프로그래밍 - 상속

### 상속 개념

> 상속이란 클래스 간 관계를 설정해서 정보를 계층적으로 관리해서 중복을 방지하고, 코드의 재사용성을 높이는 객체 지향 프로그래밍 방식 → 상속되는 클래스 전체에게 동일한 정책을 적용하기 위해 사용한다.
> 
- 부모 클래스의 필드와 메소드를 자식 클래스에게 물려줄 수 있음. → 내가 사용하고 있는 메모리 공간의 확장임 → 자식이 부모가 가지고 있는 메모리를 포함해서 확장해라(`extends`)

### 클래스의 구성 요소

- 메소드 : 오퍼레이션이라고도 함. → 속성(데이터)를 변화시킬 수 있음.
    - public : + 기호
    - private : - 기호
    - protected : # 기호
- 객체 : 클래스의 인스턴스이며 클래스를 실체화한 것
- 객체와 클래스 사이의 관계 표현
    - Ex. Account와 Application : Account는 Application 메인 클래스에서 실체화되서 관계를 맺고, Application 클래스에서 객체화된 Account 인스턴스의 속성과 메소드를 사용함.
    - 연관 관계는 의존 관계와 마찬가지로 객체를 생성하는 관계

### 클래스 상속

- 부모 클래스 = 슈퍼 클래스, 기본 클래스
- 자식 클래스 = 서브 클래스, 파생 클래스
    - 부모 클래스의 모든 멤버 요소를 소유할 뿐만 아니라 그 밖에도 고유한 멤버 메서드와 변수를 추가할 수 있음
- 자바는 단일 상속 원칙임. → 하나의 부모만을 가진다 → `extends` 뒤에 하나의 부모 클래스만 상속
    - 참고로, C++은 다중 상속을 허용한다.
- Is - A 관계(is a relationship) : Is-A 관계는 상속을 나타냄
    - ‘…는 …이다’ 라는 의미, 부모 - 자식 관계 → 고양이는 동물이다 (Cat is a Animal) → `Cat extends Animal`
    - 모든 클래스는 `java.lang.Object`의 하위 클래스이다.
    - 자바의 모든 클래스는 쓰레드 단위로 운영됨. → `Object` 클래스가 쓰레드 단위로 운영될 수 있도록 기능을 제공해줌 → 오브젝트 클래스를 상속 받는 자바의 모든 클래스는 쓰레드 단위로 운영될 수 있음.

### 상속의 유형

**단일 상속**

- 정보 관리가 용이함. 추적하기가 쉬움

```java
package javabasic_02.day11.inheritance.quiz;

public class Father {
    private String familyName = "엔지니어";
    private String houseAddress = "충남 공주시";

    public String getFamilyName() {
        return familyName;
    }

    public String getHouseAddress() {
        return houseAddress;
    }

}

package javabasic_02.day11.inheritance.quiz;

public class Son extends Father{
    private String name = "Jason";

    public String getName() {
        return name;
    }

    public void printDetails() {
        System.out.println("나의 이름은 "+this.getName());
        System.out.println("나의 아버지는 "+this.getFamilyName());
        System.out.println("나의 집은 " + this.getHouseAddress());

    }

    public static void main(String[] args) {
        Son objSon = new Son();
        objSon.printDetails();
    }
}

```

**다단계 상속**

- 클래스가 하나의 클래스에 상속하고, 상속 받은 자식 클래스가 또 다른 클래스로 상속하는 것을 말함

**계층적 상속**

- 단일 부모의 속성과 메소드를 여러 자식 클래스에게 상속하는 것을 말함.

```java
package javabasic_02.day11.inheritance.quiz;

public class Daughter extends Father{

    private String name = "Janifer";

    public String getName() {
        return this.name;
    }

    public void printDetail() {
        System.out.println("나의 이름은 "+this.getName());
        System.out.println("나의 아버지는 "+this.getFamilyName());
        System.out.println("나의 집은 " + this.getHouseAddress());
    }
    
    public static void main(String[] args) {
        Son objSon = new Son();
        objSon.printDetails();

        Daughter objDauther = new Daughter();
        objDauther.printDetail();
    }

}

```

### System.out.printf 관련 디버깅

1. **`printf`의 너비 계산과 한글의 바이트 문제:**
    - `printf`의 `%s` 포맷은 내부적으로 문자열의 **바이트 수**를 기준으로 너비를 계산하는 경우가 많습니다.
    - 영문자(ASCII)는 한 글자당 1바이트를 차지합니다.
    - 한글(UTF-8)은 한 글자당 보통 3바이트를 차지합니다.
    - 따라서 `printf("%-12s", "상품명")`을 사용하면, "상품명"은 3글자이지만 바이트로는 9바이트를 차지하게 됩니다. `printf`는 12바이트 너비에서 9바이트를 제외한 나머지 3바이트를 공백으로 채웁니다.
    - 이때, 화면에 보이는 글자 수는 3글자 + 3칸의 공백이므로, 총 6글자 너비가 확보됩니다.
    - "단가" 같은 2글자 한글은 6바이트를 차지하므로, 12바이트에서 6바이트를 제외한 6바이트가 공백으로 채워집니다. 화면에는 2글자 + 6칸의 공백, 총 8글자 너비가 확보됩니다.
    - 결국, 한글 글자 수에 따라 공백의 수가 달라져서 표의 세로 줄이 맞지 않게 됩니다.
2. **`\t` (탭)의 역할:**
    - `\t`는 터미널이나 텍스트 에디터에서 설정된 **탭 간격**에 따라 자동으로 다음 탭 위치로 커서를 이동시키는 역할을 합니다.
    - 대부분의 터미널은 탭 간격이 8칸으로 설정되어 있습니다.
    - `%-12s`로 인해 `상품명` 뒤에 공백이 생기고, 그 상태에서 `\t`를 만나면 현재 위치에서 다음 8칸 단위의 위치로 이동합니다.

### `%s\t`를 사용했을 때 줄이 맞는 이유

`printf("%-12s\t", "상품명")`을 사용하면 다음과 같은 순서로 작동합니다.

1. **`%-12s` 실행:** `printf`는 12바이트를 할당하고 "상품명"을 출력한 뒤, 남은 공간을 공백으로 채웁니다. (`"상품명 "`)
2. **`\t` 실행:** 그 뒤에 `\t`를 만나면, 현재 출력 위치에서 가장 가까운 다음 탭 위치(예: 8, 16, 24번째 칸)로 커서를 옮깁니다.

이러한 **`printf`의 고정 너비와 `\t`의 상대적인 탭 이동 기능이 결합**되어, 한글의 바이트 길이로 인해 생긴 불규칙한 간격을 `\t`가 한 번 더 보정해주는 효과를 냅니다.

### 메소드 오버라이딩

- 부모 클래스에서 정의된 메소드를 자식 클래스에서 재정의하는 것을 의미함.
    - 오버라이딩은 **인스턴스 메소드**에서만 가능함. 다형성(polymorphism)의 핵심 개념으로, 부모 클래스의 메소드를 자식 클래스에서 재정의하는 것
    - **동작 방식:** 컴파일 시점이 아닌 **런타임 시점에 호출될 메소드가 결정됨**. 즉, `Parent p = new Child();`와 같이 선언했을 때, `p.method()`를 호출하면 실제 객체인 `Child`의 메소드가 실행됩니다.

### `static` 메소드의 특징

`static` 메소드는 클래스에 종속된 메소드입니다.

- **동작 방식:** 인스턴스에 종속되지 않고 **클래스 이름으로 호출**됩니다. 컴파일러는 **컴파일 시점에 어떤 메소드를 호출할지 미리 결정**합니다.

### `static` 메소드는 왜 오버라이딩이 불가능한가?

오버라이딩은 런타임에 동적으로 메소드를 찾아가는 반면, `static` 메소드는 컴파일 시점에 정적으로 결정됩니다. 이 두 가지 메커니즘은 서로 상충하기 때문에 `static` 메소드는 오버라이딩될 수 없습니다.

대신, `static` 메소드에 한해서는 **메소드 숨기기(Method Hiding)** 개념이 적용됩니다.

### 메소드 숨기기(Method Hiding)

부모 클래스의 `static` 메소드와 똑같은 이름, 매개변수, 반환형을 가진 `static` 메소드를 자식 클래스에서 정의하면, 부모 클래스의 메소드는 자식 클래스에서 **'가려지게'** 됩니다.

- `Parent.staticMethod()`를 호출하면 부모의 메소드가 실행됩니다.
- `Child.staticMethod()`를 호출하면 자식의 메소드가 실행됩니다.
- **`Parent p = new Child();` 상태에서 `p.staticMethod()`를 호출하면, 여전히 부모 클래스의 메소드가 실행됩니다.** 이는 컴파일러가 변수 타입(`Parent`)을 기준으로 메소드를 결정하기 때문입니다.