# 25.08.21.(목) 람다식, 내/외부 반복자 및 스트림

### 백엔드 개발이란?

WWW (World Wide Web) : 소프트웨어적인 개념

- 인터넷에서 HTTP 프로토콜을 통해 주고받는 통신

Internet : 하드웨어적인 개념

- 전 세계의 네트워크를 연결하는 물리적인 망

API 개발과 서버 개발을 통해 프론트에 데이터를 안정적으로 전달, 관리

스마트폰의 등장으로 인한 서비스 환경의 분화 → 프론트엔드 + 백앤드 (서비스 개발 회사로 분화)

기술 스택 맞추기 

프로젝트 경험 : 개인 프로젝트 + 팀 프로젝트

## 스트림

> Java8 부터 컬렉션 및 배열의 요소를 반복 처리하기 위해 스트림 사용
**요소들이 하나씩 흘러가면서 처리된다는 의미**
> 

- 스트림과 Iterator 차이점
    - 내부 반복자이므로 처리 속도가 빠르고 병렬 처리에 효율적
    - 람다식으로 다양한 요소 처리를 정의
    - 중간 처리와 최종 처리를 수행하도록 파이프 라인을 형성

### **내부 반복자와 외부 반복자의 차이**

- **외부 반복자 (Iterator)**:
    - **순회 제어**: 개발자가 `next()`, `hasNext()`와 같은 메서드를 직접 호출하여 순회 과정을 **명시적으로 제어**합니다.
    - **장점**: 순회 과정에 대한 **세밀한 제어**가 가능합니다. 예를 들어, 순회 도중에 특정 조건을 만족하면 반복을 중단하거나, 요소를 제거할 수 있습니다.
    - **단점**: 코드가 길어질 수 있고, 멀티스레드 환경에서 병렬 처리가 어렵습니다.
- **내부 반복자 (Stream)**:
    - **순회 제어**: 순회 로직을 API에 위임하며, 개발자는 `forEach()`, `map()`, `filter()`와 같은 **메서드를 통해 어떤 작업을 할지만 명시**합니다.
    - **장점**: 코드가 간결하고 가독성이 높습니다. 또한, 내부적으로 병렬 처리를 효율적으로 수행할 수 있어 대용량 데이터 처리에 유리합니다.
    - **단점**: 순회 과정을 직접 제어하기 어렵습니다. 예를 들어, `forEach()`를 통해 반복문을 중간에 멈추는 것은 불가능합니다.

### 향상된 for문과 반복자

> 향상된 for문(`for-each`)은 내부적으로 `Iterator`를 사용하지만, 개발자가 직접 `next()`와 `hasNext()` 메서드를 호출하는 방식은 아닙니다. 이는 반복자를 추상화하여 사용자가 순회 로직을 직접 제어하지 않고도 컬렉션의 모든 요소를 순서대로 처리할 수 있게 해줍니다.
> 

> 하지만 **순회 제어 주체** 측면에서 보면, 향상된 for문은 여전히 **개발자가 반복의 시작과 끝을 제어**하기 때문에 **외부 반복자**로 분류됩니다. `Stream` API와 같은 **내부 반복자**는 순회 로직을 프레임워크에 완전히 위임하는 반면, 향상된 for문은 `for` 루프 블록 내에서 개발자가 원하는 작업을 직접 수행할 수 있습니다.
> 

**결론**:
향상된 for문은 **`Iterator`를 추상화한 형태**이며, 순회 제어 주체가 개발자에게 있기 때문에 **외부 반복자**에 속합니다. 이는 `Stream`의 내부 반복자와는 구분됩니다.

### 스트림의 파이프 라인

- 컬렉션의 오리지널 스트림 뒤에 필터링 중간 스트림이 연결될 수 있고, 그 뒤에 매핑 중간 스트림이 연결될 수 있음.

1. 데이터 소스 (리소스)
스트림은 데이터를 처리하는데 사용할 수 있는 다양한 소스로부터 생성된다.
이 데이터 소스는 컬렉션, 배열, 파일, .. 등 다양한 형태이다.
2. 연속된 작업
스트림은 중간 연산과 최종 연산으로 구성된다. 
중간 연산은 스트림을 반환하며, 여러 중간 연산을 연결할 수 있다.
최종 연산은 스트림 파이프라인을 종료하고 결과를 생성한다.
3. 파이프라인
스트림에서 제공하는 중간 연산과 최종 연산을 연결하여
데이터를 처리하는 구조를 파이프 라인이라고 한다. (인공지능 회사에서 자바 개발자들을 통해 데이터 스트림 전처리를 필요로 하는 경우가 많다.)
4. 지연 연산
스트림은 지연 연산을 지원한다. (메모리에 담겨져 있지 않고(= `stateless` ) 스트림에 가둬짐 ~ 데이터가 메모리에 별도로 저장되는 것이 아니라, 데이터 처리 파이프라인 내에서만 존재하고 흐른다는 의미)
중간 연산들이 실제로 수행되기 전까지 스트림 파이프라인이 실행되지 않는다.
필요한 연산만 수행해서 최적의 성능을 이끌어 내기 위함이다.
최종 연산이 호출이 되면, 최종 결과를 생성하고 스트림이 해제된다.
이런 특징 때문에 데이터 스트림을 메모리에 로드하지 않고 최적의 성능을 낼 수 있다.
5. 순차 및 병렬 처리
스트림은 순차적으로 처리할 수 있고, 병렬(멀티 CPU)로도 처리될 수 있다. 

### map() 과 flatMap() 차이 정리

### `map()`: 1 대 1 변환

`map()`은 스트림의 각 요소를 **하나의 다른 요소로 변환**합니다. 즉, 입력 스트림의 요소 하나당 출력 스트림의 요소 하나가 생성되는 **1 대 1 매핑**입니다.

- **용도**: 데이터를 변형할 때 사용합니다. 예를 들어, `User` 객체 스트림에서 각 사용자의 이름(`String`)만 추출하거나, 숫자를 제곱하는 등의 간단한 변환에 적합합니다.
- **반환 타입**: `Stream<T>`를 `Stream<R>`로 변환합니다. 여기서 `T`는 원본 요소 타입이고 `R`은 변환된 요소 타입입니다.

**예시**:
`List<Integer>`에서 각 숫자를 제곱하여 새로운 스트림을 만듭니다.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3);
List<Integer> squaredNumbers = numbers.stream()
                                      .map(n -> n * n)
                                      .collect(Collectors.toList());
// 결과: [1, 4, 9]
```

---

### `flatMap()`: 1 대 다(多) 변환

`flatMap()`은 스트림의 각 요소를 **하나 이상의 요소로 변환**합니다. 즉, **1 대 다 매핑**입니다. 이 메서드는 각 변환 결과를 다시 하나의 단일 스트림으로 **평탄화(flattening)**하는 특징이 있습니다.

- **용도**: 스트림 안의 스트림(Stream of Streams)과 같은 중첩된 구조를 **하나의 평평한 스트림으로 만들 때** 사용합니다. 예를 들어, `List<List<String>>`과 같이 중첩된 리스트를 단일 `List<String>`으로 만들거나, 문장 스트림에서 모든 단어 스트림을 추출할 때 유용합니다.
- **반환 타입**: `Stream<Stream<T>>`와 같이 중첩된 스트림을 `Stream<T>`로 변환합니다.

**예시**:
문장 리스트에서 모든 단어를 추출하여 하나의 스트림으로 만듭니다.

```java
`List<String> sentences = Arrays.asList("Hello World", "Java is fun");
List<String> words = sentences.stream()
                              .flatMap(sentence -> Arrays.stream(sentence.split(" ")))
                              .collect(Collectors.toList());
// 결과: ["Hello", "World", "Java", "is", "fun"]`

```

**요약: 언제 무엇을 쓸까?**

- `map()`은 **하나의 입력에 하나의 결과**가 필요한 경우 사용하세요.
- `flatMap()`은 **하나의 입력이 여러 개의 결과를 만들고, 그 결과들을 하나의 스트림으로 합쳐야** 할 때 사용하세요.

### 스트림 인터페이스

  BaseStream : 모든 스트림에서 사용할 수 있는 공통 메소드가 정의되어 있음.

          | 

    |———————————|—————|——————|

Stream(객체요소 처리)    Instream      LongStream     DoubleStream

1. **컬렉션으로부터 스트림 얻는 방법**
모든 컬레션으로부터 객체 스트림을 얻을 수 있다.
2. **배열로부터 스트림 얻는 방법**
`java.util.Arrays` 클래스를 이용하면 다양한 종류의 배열로부터 다양한 스트림을 얻어 낼 수 있다.
3. **숫자 범위로부터 스트림을 얻기**
IntStream, LongStream의 정적 메소드 range(), rangeClosed() 메소드를 이용하면 
특정 범위의 정수 스트림을 얻을 수 있다. 첫번째 매개값은 시작 수, 두번째 매개값은 끝 수
끝수를 포함하지 않으려면 `range()`, 포함하려면 `rangeClosed()`
4. **파일로부터 스트림을 얻기**
`java.nio.file.Files`의 `lines()` 메소드로 텍스트 파일의 행 단위 스트림을 얻을 수 있음.

```java
public class RangeStreamEx {
    public static int sum = 0;
    public static int sum2 = 0;

    public static void main(String[] args) {

        IntStream i1_100 = IntStream.rangeClosed(1,100);
        i1_100.forEach(number -> sum += number); // sum이 지역변수면 안됨
        System.out.println(sum);

        IntStream i1_10 = IntStream.range(1,11);
        i1_10.forEach(number -> sum2 += number);
        System.out.println(sum2);

    }
}
```

자바의 `Stream` API 안의 람다식에서 **지역변수를 사용할 수 있습니다.** 하지만 **수정할 수는 없습니다.**

---

### **지역변수를 수정할 수 없는 이유**

스트림의 람다식은 **캡처(capture)**된 지역변수에 대해 **`effectively final`** 규칙을 따릅니다. 이는 변수가 `final` 키워드로 선언되지 않았더라도, 한 번 값이 할당된 후 **다시는 변경되지 않아야 함**을 의미합니다.

이러한 제약이 존재하는 주요 이유는 다음과 같습니다.

1. **동시성(Concurrency) 문제**: 스트림은 `parallelStream()`을 통해 병렬 처리를 지원합니다. 만약 여러 스레드가 동시에 하나의 지역변수를 수정하려 한다면, 데이터 불일치나 예상치 못한 결과(Race Condition)가 발생할 수 있습니다.
2. **안전성 보장**: `effectively final` 규칙을 통해 람다식이 캡처한 변수의 상태가 변경되지 않도록 보장하여, 함수형 프로그래밍의 불변성(Immutability) 원칙을 유지합니다.

### **예시를 통한 이해**

**가능한 경우 (지역변수 사용)**:

```java
public class LambdaExample {
    public static void main(String[] args) {
        int bonus = 100; // 지역변수

        List<Integer> salaries = Arrays.asList(1000, 2000, 3000);

        salaries.stream()
                .map(salary -> salary + bonus) // 'bonus' 지역변수 사용
                .forEach(System.out::println);
    }
}
```

위 예시에서 `bonus` 변수는 람다식 내에서 사용되지만, **수정되지 않으므로** 정상적으로 컴파일되고 실행됩니다.

---

**불가능한 경우 (지역변수 수정 시도)**:

```java
public class LambdaExampleError {
    public static void main(String[] args) {
        int count = 0; // 지역변수

        List<Integer> numbers = Arrays.asList(1, 2, 3);

        numbers.stream()
                .forEach(n -> {
                    // 컴파일 오류 발생!
                    // 'Local variable count defined in an enclosing scope must be final or effectively final'
                    count = count + n; 
                });
    }
}
```

위 코드는 `forEach` 람다식 내에서 `count` 변수를 수정하려고 시도했기 때문에 컴파일 오류가 발생합니다.

### **결론**

스트림의 람다식 내에서 지역변수를 읽는 것은 가능하지만, **값을 변경하는 것은 불가능**합니다. 이는 자바가 함수형 프로그래밍의 불변성과 멀티스레드 환경에서의 안전성을 보장하기 위한 중요한 규칙입니다.

스트림의 람다식에서 **지역변수만 `effectively final` 규칙**의 영향을 받으며, **전역변수(정확히는 인스턴스 변수 또는 클래스 변수)는 자유롭게 수정할 수 있습니다.**

---

### **지역변수와 전역변수의 차이점**

- **지역변수**: 메서드 내에서 선언되며, 해당 메서드 호출 스택에 할당됩니다. 멀티스레드 환경에서 여러 스레드가 같은 메서드를 호출하면 각 스레드는 고유한 지역변수 사본을 갖게 됩니다. 하지만 **람다식은 그 변수를 캡처해서 사용**하기 때문에, 여러 람다식이 같은 지역변수를 동시에 수정하려 할 경우 **동시성 문제(Concurrency Issue)**가 발생할 수 있습니다. 그래서 JVM이 안전성을 위해 수정을 막는 것입니다.
- **전역변수 (인스턴스 변수/클래스 변수)**: 힙(Heap) 메모리에 할당되며, 해당 객체(인스턴스) 또는 클래스에 속합니다. 따라서 **여러 스레드가 하나의 전역변수에 동시에 접근하고 수정할 수 있습니다.**

---

### **전역변수와 멀티스레드 환경의 위험성**

전역변수는 여러 스레드에 의해 공유되기 때문에, `Stream.parallel()`과 같은 병렬 처리 환경에서 **데이터 불일치(Data Inconsistency)**가 발생할 수 있습니다.

**예시**:

```java
public class GlobalVariableExample {
    private int count = 0; // 전역변수

    public void run() {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // 병렬 스트림으로 count를 증가시키면
        numbers.parallelStream().forEach(n -> count += n);

        System.out.println(count); // 예상치 못한 값이 나올 수 있음 (race condition)
    }
}
```

위 코드는 `parallelStream()`을 사용하기 때문에 여러 스레드가 `count` 변수에 동시에 접근하여 값을 수정합니다. 이 경우 **레이스 컨디션(Race Condition)**이 발생하여 최종 `count` 값이 예상과 다르게 나올 수 있습니다.

따라서, 자바는 지역변수와 달리 전역변수의 수정은 막지 않지만, **개발자가 직접 동기화(Synchronization) 처리를 해주어야** 멀티스레드 환경에서 안전성을 보장할 수 있습니다.

### 퀴즈 - 스트림

1. 스트림에 대한 설명으로 틀린 것은 무엇입니까?
    1. 스트림은 내부 반복자를 사용하기 때문에 코드가 간결해진다.
    2. 스트림은 요소를 분리해서 병렬 처리시킬 수 있다.
    3. 스트림은 람다식을 사용해서 요소 처리 내용을 기술한다.
    4. 스트림은 요소를 모두 처리하고 나서 처음부터 요소를 다시 반복시킬 수 있다.(X)
2. 스트림을 얻을 수 있는 소스가 아닌 것은?
    1. 컬렉션(List)
    2. int, long, double 범위 (X)
    3. 디렉토리
    4. 배열
3. 스트림 파이프라인에 대한 설명으로 틀린 것은 무엇입니까?
    1. 스트림을 연결해서 중간 처리와 최종 처리를 할 수 있다.
    2. 중간 처리 단계에서는 필터링, 매핑, 정렬, 그룹핑을 한다.
    3. 최종 처리 단계에서는 합계, 평균, 카운팅, 최대값, 최소값 등을 얻을 수 있다.
    4. 최종 처리 단계가 없더라도 중간 처리를 할 수 있다. (x) → 스트림은 데이터를 필요한 시점에 처리를 하는 지연 연산이라는 특징을 가진다. : 최종 연산이 호출될 때까지 중간 연산들을 실행하지 않고 기다린다. 
4. 스트림 병렬 처리에 대한 설명으로 틀린 것은 무엇입니까?
    1. 전체 요소를 분할해서 처리한다.
    2. 내부적으로 포크조인 프레임워크를 이용한다.
        1. **포크(Fork)**:
        스트림을 병렬로 처리할 때, `ForkJoinPool`은 큰 작업을 재귀적으로 더 작은 **서브태스크(sub-task)**로 분할합니다. 예를 들어, 1000개의 요소가 있는 스트림을 500개씩 두 그룹으로 나누고, 다시 250개씩 네 그룹으로 나누는 식으로 작업을 쪼갭니다.
        2. **병렬 처리**:
        분할된 서브태스크들은 별도의 스레드에서 동시에 처리됩니다. 각 스레드는 할당된 작업만 집중적으로 처리하여 전체 작업 시간을 단축시킵니다.
        3. **조인(Join)**:
        각 서브태스크의 처리가 완료되면, 그 결과들을 다시 합쳐서(join) 최종 결과를 만듭니다. 이 과정에서 합산(`sum`), 평균(`average`), 목록 수집(`collect`) 등의 연산이 수행됩니다.
        4. **스트림에서의 역할**
        
        개발자가 `stream()` 대신 `parallelStream()`을 호출하면, 자바는 내부적으로 이 포크/조인 프레임워크를 사용해 데이터를 자동으로 분할하고 병렬로 처리합니다. 개발자가 직접 스레드를 관리하거나 동기화 문제를 다룰 필요 없이, **선언적으로 병렬 처리를 요청**할 수 있게 되는 것입니다.
        
    3. 병렬 처리는 순차적 처리보다 항상 빠른 처리를 한다(X)
    4. 내부적으로 스레드풀을 이용해서 스레드를 관리한다.
5. List에 저장되어 있는 String 요소에서 대소문자와 상관없이 ‘java’라는 단어가 포함된 문자열만 필터링해서 출력하려고 합니다. 빈칸에 알맞은 코드를 작성해보세요.

```java
        list.stream()
                .filter(string -> string.toLowerCase().contains("java"))
                .forEach(System.out::println);
```

1. List에 저장되어 있는 Member의 평균 나이를 출력하려고 합니다. 빈칸에 알맞은 코드를 작성해보세요.

```java
        double avg = list.stream()
                .mapToInt(member -> member.getAge())
                .average().getAsDouble();
```

1. List에 저장되어 있는 Member 중에서 직업이 ‘개발자’인 사람만 별도의 List에 수집하려고 합니다. 빈칸에 알맞은 코드를 작성해보세요.
```java
        List<Member> developers = list.stream()
                .filter(member -> member.getJob().equals("개발자"))
                .toList();
```