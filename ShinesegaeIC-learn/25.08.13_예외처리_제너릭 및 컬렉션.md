### 리소스 (resource)

> 데이터를 제공하는 객체 ⇒ 리소스
DAO (Data Access Object) ⇒ 데이터 처리 객체
DTO (Data Transfer Object) ⇒ 데이터 전송 객체
VO (Value Object) ⇒ 데이터 객체
> 

리소스를 사용하기 위해서는 반드시 열어야 한다. ⇒ open()

리소스를 사용이 끝난 후에는 닫아야만 한다. ⇒ close()

예) 파일의 내용을 읽기 위해서는 파일 열어야 한다. 다 읽은 다음에 파일 닫아야 다른 프로그램에서 사용할 수 있다. 
문제는 리소스를 사용하다가 예외가 발생할 수 있다. 안전하게 닫는 것이 매우 중요하다. 리소스는 불안정 상태로 남아 있게 되고 이는 자칫 데이터의 손상을 야기할 수 있다. 

데이터를 제공하는 객체를 사용할  때는 try-catch 문보다는 try-with-resource 구문 사용하는 것이 좋다.

`AutoCloseable` 인터페이스 구현한 MyResource 리소스를 `try-with-resources` 블록으로 사용하여 관리함.

`try-with-resources` 문은 `try` 블록이 정상적으로 종료되거나, 예외가 발생하여 비정상적으로 종료되는 경우 **모두** 리소스의 `close()` 메서드를 호출하도록 설계되었습니다. 이는 리소스 누수를 방지하기 위한 핵심 기능.

**try-with-resources** 문에서 리소스는 `try()` 문 안에 예외가 발생하더라도 **`catch` 블록이 실행되기 전에** 자동으로 닫힙니다.

### 예외 발생 시 순서

1. `try()` 블록 내에서 리소스 생성.
2. `try {}` 블록 내에서 예외 발생.
3. **예외가 `catch` 블록으로 전달되기 전**, 리소스의 `close()` 메서드가 호출됨.
4. `catch` 블록이 실행되어 예외를 처리함.

> 만약 `try` 블록 내에서 예외가 발생하고, 리소스의 `close()` 메서드를 호출하는 과정에서도 또 다른 예외가 발생하면, `try` 블록에서 발생한 원래의 예외는 **억제(suppressed)**되고, `close()` 메서드에서 발생한 예외가 전달됩니다. `try-with-resources`는 이 억제된 예외를 **`Throwable.getSuppressed()`** 메서드를 통해 접근할 수 있음.
> 

```java
public class MyResource implements AutoCloseable{

    private String name;

    MyResource(String name) {
        this.name = name;
        System.out.println("[MyResouce(" + name + ") 열기");
    }

    public String read1() {
        System.out.println("[MyResouce(" + name + ") 읽기");
        return "100";
    }

    public String read2() {
        System.out.println("[MyResouce(" + name + ") 읽기");
        return "abc";
    }

    @Override
    public void close() throws Exception {
        System.out.println("[MyResouce(" + name + ") 닫기");
    }
}
```

```java
public class TryWithResouceEx {
    public static void main(String[] args) {
	      // try() 블록 내부 리소스 선언
        try(MyResource resource = new MyResource("AAA")) { // [MyResouce(AAA) 열기
            String data = resource.read1(); // [MyResouce(AAA) 읽기
            int value = Integer.parseInt(data);
            System.out.println(value); // 100
        } catch (Exception e) {
            System.out.println("예외처리: "+e.getMessage());
        }
				// [MyResouce(AAA) 닫기 => catch문이 수행되지 않아 try 문이 끝나면 실행

        try(MyResource resource = new MyResource("AAA")) { // [MyResouce(AAA) 열기
            String data = resource.read2(); // [MyResouce(AAA) 읽기
            int value = Integer.parseInt(data); // [MyResouce(AAA) 닫기 ~ 예외 발생으로 
            System.out.println(value);          // catch 문 실행 전 닫아짐!
        } catch (Exception e) {
            System.out.println("예외처리: "+e.getMessage());  // 예외처리: For input string: "abc"
        }

        MyResource resource1 = new MyResource("BBB"); // [MyResouce(BBB) 열기
        MyResource resource2 = new MyResource("CCC"); // [MyResouce(CCC) 열기
        try(resource1;resource2) { 
            String data1 = resource1.read1();  // [MyResouce(BBB) 읽기
            String data2 = resource2.read2();  // [MyResouce(CCC) 읽기
        } catch(Exception e) {
            System.out.println("예외 처리 : " + e.getMessage());
        }
        
				// [MyResouce(CCC) 닫기
				// [MyResouce(BBB) 닫기

    }
}

```

### 예외 떠넘기기

기본 처리 ⇒ 메소드 내부에서 예외가 발생할 때 try-catch 블록으로 처리하는 것

`throws`를 이용하여 메소드를 호출한 곳으로 예외를 떠넘길 수 있다.

`void read1() throws 예외클래스1, 예외클래스2, ... , {}`

```java
public void method1() {
		String className = "java.lang.String2";
		try {
				method2(className);} catch (ClassNotFoundException e) {
				e.printStackTrace(); }
}

public void method2(String className) throws ClassNotFoundException{

		Class.forName(className)
}

// method2 에서 ClassNotFoundException이 발생하면 throws로 method2를 호출한
// method1에서 try - catch 문을 통해 예외를 처리한다.
```

### 제네릭

- 공식 : 결정되지 않은 타입을 파라미터로 처리하고, 실제 사용할 때 파라미터를 구체적인 타입으로 대체시키는 기능
- 타입 파라미터는 생성할 때 지정됨.
- 객체를 저장할 때 저장할 내용물의 타입을 미리 알려주고, 읽을 때 어떤 타입으로 제공할지를 알게 표시하는 법
- 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 방법, 객체별로 다른 타입의 자료가 저장될 수 있도록 지원해 준다.
- 객체 타입을 변수화한 기능

**타입 파라미터 기호 네이밍 (암묵적 규칙)**

<T> =⇒ 타입( Type)

<E> =⇒ 요소 Element List

<K> =⇒ Key, map(K,V)

<V> =⇒ value, 리턴 값, 매핑 값

<N> =⇒ 숫자

<U, S, V> =⇒ 2번째, 3번째, 4번째 선언된 타입

### 자료구조 (data structure)

> 대량의 데이터를 효율적으로 관리할 수 있는 데이터의 구조
> 

> 개발자의 입장에서는, 코드 상에서 효율적으로 데이터를 처리하기 위해서, 
데이터의 특성에 따라, 체계적으로 데이터를 구조화 해야 한다.
> 
- 어떤 데이터 구조를 사용하느냐에 따라 코드 효율성이 달라진다. 즉, 성능이 달라진다.
- 부하 테스트는 얼마나 해보셨나요? 얼만큼의 트래픽을 경험해보셨나요? 라는 질문에 자료 구조와 알고리즘을 활용해서 대답할 수 있어야 한다.

**알고리즘이란?**

어떤 문제를 풀기 위한 절차/방법

어떤 문제에 대해, 특정한 입력을 넣으면, 원하는 출력을 얻을 수 있도록 만드는 프로그래밍

### 컬렉션 (Collection<E> 를 구현)

1. List  계열 (객체의 저장 순서가 있고, 중복을 허용함)
2. Set 계열 (객체의 저장 순서가 없고, 중복을 허용하지 않음)

### Map 계열 (Collection<E> 를 구현X)

- 키를 가지고 값을 관리한다. 즉, 키(중복허용X)와 값이 한 쌍으로 관리된다.

### Queue 큐 : First-In First-Out

용어

1. Enqueue : 큐에 데이터를 넣는 기능 - add(value), offer(value)
2. Dequeue : 큐에서 데이터를 꺼내는 기능 - poll(), remove()

java에서는 java.util.Queue 인터페이스를 제공하고 있다.

**멀티태스킹을 위한 프로세스 스케쥴링 방식을 구현할 때 적용**

### Stack 스택 : Last-In First-Out

스택 구조는 데이터를 제한적으로 접근할 수 있는 구조이다. (한쪽 끝에서만 데이터를 넣거나 뺄 수 있는 구조)

구조가 단순해서, 구현이 쉽다. 데이터 저장/읽기 속도가 빠르다

데이터 최대 개수를 미리 정해놔야 한다. 저장공간의 낭비가 발생할 수 있다. ⇒ 보통 배열로 만듦

자바에서는 java.util.Stack 제공 push(), pop() 메소드를 제공함.

### Quiz - 예외처리

1. 예외에 대한 설명 중 틀린 것은 무엇입니까?
    1. 예외는 사용자의 잘못된 조작, 개발자의 잘못된 코딩으로 인한 프로그램 오류를 말한다.(O)
    2. RuntimeException의 하위 예외는 컴파일러가 예외 처리 코드를 체크하지 않는다.(O)
    3. 예외는 try-catch 블록을 사용해서 처리된다.(O)
    4. 자바 표준 예외만 프로그램에서 처리할 수 있다.(X)
2. try - catch - finally 블록에 대한 설명 중 틀린 것은 무엇입니까?
    1. try {} 블록에는 예외가 발생할 수 있는 코드를 작성한다.
    2. catch {} 블록은 try {} 블록에서 발생한 예외를 처리하는 블록이다.
    3. try {} 블록에서 return 문을 사용하면 finally 블록은 실행되지 않는다. (X) 
    4. catch {} 블록은 예외의 종류별로 여러 개를 작성할 수 있다.
    
    ### **try-finally** 블록의 실행 순서 (feay. Gemini)
    
    1. **`try` 블록 실행**: 코드 실행이 `try` 블록으로 진입합니다.
    2. **`return` 문 만남**: `try` 블록 내부에서 `return` 문을 만나면, 반환될 값을 임시로 저장합니다.
    3. **`finally` 블록 실행**: **`try` 블록이 종료되기 전에** `finally` 블록이 실행됩니다.
    4. **`try` 블록 종료**: `finally` 블록의 실행이 끝난 후에야 `try` 블록이 완전히 종료되고, 임시로 저장해두었던 값이 반환됩니다.
    
    ### **finally** 블록의 역할
    
    **finally** 블록은 `try` 블록이 정상적으로 종료되든, 예외가 발생하든, `return` 문을 통해 종료되든 **항상 실행**되도록 보장하는 역할을 합니다. 이 덕분에 개발자는 파일 핸들, 데이터베이스 연결, 네트워크 소켓과 같은 **리소스 정리(clean-up)** 코드를 안전하게 작성할 수 있습니다.
    
    ### 주의할 점
    
    만약 **`finally` 블록 내부에도 `return` 문이 있다면** `try` 블록의 `return` 값은 무시되고, **`finally` 블록의 `return` 값이 최종적으로 반환**됩니다. 이러한 코딩 방식은 의도하지 않은 결과를 초래할 수 있으므로 일반적으로 권장되지 않습니다.
    
3. throws에 대한 설명으로 틀린 것은 무엇입니까?
    1. 생성자나 메소드의 선언 끝 부분에 사용되어 내부에서 발생된 예외를 떠넘긴다. 
    2. throws 뒤에는 떠넘거야 할 예외를 쉼표(,)로 구분해서 기술한다.
    3. 모든 예외를 떠넘기기 위해 간단하게 throws Exception으로 작성할 수 있다.
    4. 새로운 예외를 발생시키기 위해 사용된다. (X)

1. throw에 대한 설명으로 틀린 것은 무엇입니까?
    1. 예외를 최초로 발생시키는 코드이다.
    2. 예외를 호출한 곳으로 떠넘기기 위해 메소드 선언부에 작성된다.(X)
    3. throw로 발생된 예외는 일반적으로 생성자나 메소드 선언부에 throws로 떠넘겨진다.
    4. throw 키워드 뒤에 예외 객체 생성 코드가 온다.
2. 메소드가 다음과 같이 선언되어 있습니다. 잘못된 예외 처리를 선택하세요.

![image.png](attachment:a6c89192-5f83-47e8-955c-5a9663c25864:image.png)

- 3번?! : 작은 범위 부터 큰 범위로 예외 처리를 해줘야 하나 큰 범위 후 작은 범위로 예외 처리함.
1. 다음 코드가 실행되었을 때 출력 결과를 작성해보세요.

실행 결과

```java
10
숫자로 변환할 수 없음
10
인덱스를 초과했음
10
```

1. 

```java
public class NotExistIDException extends Exception{
    public NotExistIDException() {}
    public NotExistIDException(String message) {
        super(message);
    }
}

public class WrongPasswordException extends Exception{
    public WrongPasswordException() {}
    public WrongPasswordException(String message) {
        super(message);
    }
}

    public static void login(String id, String password) throws NotExistIDException, WrongPasswordException {
        if(!id.equals("blue")) {
            throw new NotExistIDException("아이디가 존재하지 않습니다.");
        }

        if(!password.equals("12345")) {
            throw new WrongPasswordException("패스워드가 틀립니다.");
        }
    }
```

1. Try with Resources 사용하기!

```java
package java_advanced_01.day14.exceptionEx.prob8Ex;

import java.io.IOException;

public class FileWriter implements AutoCloseable{
    public FileWriter(String filePath) throws IOException {
        System.out.println(filePath + " 파일을 엽니다.");
    }

    public void write(String data) throws IOException {
        System.out.println(data + "를 파일에 저장합니다.");
    }

    @Override
    public void close() throws IOException {
        System.out.println("파일을 닫습니다.");

    }
}

```

```java
public class FileWriterExample {
    public static void main(String[] args) {

        try (FileWriter fw = new FileWriter("file.txt")){
            fw.write("Java");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### Quiz - 컬렉션

1. 자바의 컬렉션 프레임워크에 대한 설명으로 틀린 것은 무엇입니까?
    1. List 컬렉션은 인덱스로 객체를 관리하며 중복 저장을 허용한다.
    2. Set 컬렉션은 순서를 유지하지 않으며 중복 저장을 허용하지 않는다
    3. Map 컬렉션은 키와 값으로 구성된 Map.Entry를 저장한다.
    4. Stack은 FIFO(선입선출) 자료구조를 구현한 클래스이다.(X)
2. List 컬렉션에 대한 설명 중 틀린 것은 무엇입니까?
    1. 대표적인 구현 클래스로는 ArrayList, Vector, LinkedList가 있다.
    2. 멀티 스레드 환경에서는 ArrayList보다는 Vector가 쓰레드에 안전하다(?)
        1. `Vector`는 모든 메소드가 `synchronized` 키워드로 동기화되어 있어 스레드에 안전(thread-safe)합니다. 반면 `ArrayList`는 동기화되어 있지 않아 스레드에 안전하지 않습니다.
    3. ArrayList에서 객체를 삭제하면 삭제된 위치는 비어 있게 된다. (X)
        1. **ArrayList**는 내부적으로 배열을 사용합니다. **객체를 삭제하면, 삭제된 객체보다 뒤에 있는 모든 객체들이 한 칸씩 앞으로 당겨집니다.** 이로 인해 배열에 빈 공간이 생기지 않고, 리스트의 크기가 줄어듭니다.
    4. 중간 위치에 객체를 빈번히 삽입하거나 제거할 경우 LinkedList를 사용하는 것이 좋다
3. Set 컬렉션에 대한 설명 중 틀린 것은 무엇입니까?
    1. 대표적인 구현 클래스로는 HashSet, LinkedHashSet, TreeSet이 있다.
    2. Set 컬렉션에서 객체를 하나씩 꺼내오고 싶다면 Iterator를 이용한다.
    3. HashSet은 hashCode()와 equals() 메소드를 이용해서 중복된 객체를 판별한다.
    4. Set 컬렉션에는 null을 저장할 수 없다.
        1.  "and at most one null element"라는 문구는 `Set` 컬렉션에 **최대 한 개의 `null` 값**이 포함될 수 있다는 것을 명확히 알려줍니다.
4. Map 컬렉션에 대한 설명 중 틀린 것은 무엇입니까?
    1. 대표적인 구현 클래스로는 HashMap, Hashtable, TreeMap, Properties가 있다.
    2. HashMap과 Hashtable은 hashCode()와 equals() 메소드를 이용해서 중복 키를 판별한다.
    3. 멀티 스레드 환경에서는 Hashtable보다는 HashMap 이 스레드에 안전하다. (X)
        1. Hashtable은 synchronized 로 스레드에 안전하며, 스레드와 상관없는 환경이라면 HashMap을 쓰는것이 추천됨(feat. 공식 API)
    4. Properites는  키와 값이 모두 String 타입이다.
5. 단일 (싱글) 스레드 환경에서 Board 객체를 저장 순서에 맞게 읽고 싶습니다. 가장 적합한 컬렉션을 생성하도록 밑줄 친 부분에 코드를 작성해보세요. 
    1. `List<Board> 변수 = new ArrayList<Board>();`
6. 단일 (싱글) 스레드 환경에서 학번 (String)를 키로, 점수 (Integer)를 값으로 저장하는 가장 적합한 컬렉션을 생성하도록 밑줄 친 부분에 코드를 작성해보세요.
    1. `Map<String, Integer> 변수 = new TreeMap<String, Integer>();`
7. BoardDao 객체의 getBoardList() 메소드를 호출하면 List<Board> 타입의 컬렉션을 리턴합니다. ListExample 클래스의 실행 결과를 보고, BoardDao 클래스와 getBoardList() 메소드를 작성해보세요.

![image.png](attachment:f24359e5-63bc-471b-8c20-447cade067c7:image.png)

```java
import java.util.ArrayList;
import java.util.List;

public class BoardDao {
    public List<Board> getBoardList() {
        List<Board> boards = new ArrayList<>();
        boards.add(new Board("제목1","내용1"));
        boards.add(new Board("제목2","내용2"));
        boards.add(new Board("제목3","내용3"));

        return boards;
    }
}

```

### DAO의 역할과 특징

DAO는 데이터베이스나 파일과 같은 **데이터 소스에 접근하는 로직을 분리**하기 위해 사용되는 디자인 패턴입니다. 주요 역할은 다음과 같습니다.

1. **데이터베이스 CRUD 작업**: 데이터베이스의 생성(Create), 읽기(Read), 갱신(Update), 삭제(Delete)와 같은 작업을 수행하는 메서드를 포함합니다.
2. **비즈니스 로직과 분리**: 애플리케이션의 핵심 비즈니스 로직(예: 게시판 글쓰기, 수정)과 데이터 접근 로직(예: SQL 쿼리 실행)을 분리하여 코드의 재사용성과 유지보수성을 높입니다.
3. **데이터 모델 객체 사용**: 데이터베이스 테이블의 레코드 하나를 나타내는 **DO(Domain Object)** 또는 **DTO(Data Transfer Object)**와 같은 객체를 사용하여 데이터를 전달합니다. 제시된 코드에서 `Board` 클래스가 이 역할을 수행하고 있습니다.

### 제시된 코드의 역할

- **`Board` 클래스**: 게시판의 게시물 정보를 담는 데이터 모델 객체입니다. DAO가 이 객체를 통해 데이터를 전달합니다.
- **`BoardDao` 클래스**: 데이터 접근 객체입니다. `getBoardList()` 메서드를 통해 게시물 목록 데이터를 제공합니다. 이 예제에서는 실제 데이터베이스 대신 메모리에 데이터를 직접 생성하고 있지만, 실제로는 데이터베이스에서 데이터를 조회하는 코드가 들어갑니다.
- **`ListExample` 클래스**: 애플리케이션의 실행 로직을 담당하는 클래스입니다. `BoardDao`를 사용하여 게시물 데이터를 가져와 출력하는 역할을 합니다.