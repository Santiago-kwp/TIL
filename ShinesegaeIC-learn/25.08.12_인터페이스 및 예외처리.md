## 인터페이스

### 인터페이스의 개념 정리

선물 포장지와 같은 인터페이스 : 인터페이스를 구현한다면 여러가지 기능들을 쓸 수 있어! 입주자 여러분 이 인터페이스를 구현하시면 수영장, 헬스장, 조식뷔폐 등의 여러가지 기능들을 제공드립니다. 우리 인터페이스를 구현해주세요. 인터페이스는 초콜릿 상자와 같다.(feat. 포레스트 검프)

**인터페이스의 정의 : 다양한 객체들이 공통적으로 가져야할 기능들을 규격(메소드 정의)으로 정의해 놓은 설계도 혹은 규약. 이를 통해 객체 간의 느슨한 결합을 가능하게 하고, 다형성을 활용하여 코드를 더 유연하고 확장성있게 만듭니다.**

- 인터페이스는 다형성을 구현하는데 핵심적인 역할을 함.

인터페이스는 구현할 기능에 대한 일반화

구현 방법 : `public class 구현클래스명 implements interfaceA, interfaceB, interfaceC, ... {}`

`public class AAA extends AAAB implements 날다, 먹다, 소리내다 {}`

- AAA라는 클래스는 AAAB라는 클래스의 필드와 기능을 공유할 수 있고, 날고, 먹고, 소리내는 기능을 사용할 수 있다.
- 날고, 먹고, 소리내는 기능은 AAA에 맞도록 반드시 구현 해주어야 한다.

### 인터페이스의 구성 요소

- 상수필드 public static final
- 추상 메소드 public 리턴유형 method명();
- 디폴트 메소드 : 유일한 구현 메소드
- private 메소드
- static 메소드
- private static 메소드

### 인터페이스 상속

- `interfaceA extends B, C, .... {}` : 인터페이스 간 다중 상속 지원
- `public class 구현 클래스 implements A {}`

### 인터페이스 타입 변환

- 인터페이스와 구현 클래스 간에 발생한다.
- 인터페이스 참조변수에 구현 객체를 대입하면 구현 객체는 인터페이스 타입으로 자동 타입변환된다.
- 인터페이스 타입으로 자동 타입 변환
    - `RomoteControl rc = new SmartTelevision();`
    - SmartTelevision이 자동으로 RemoteControl 타입으로 변환되었다.
- 인터페이스를 구현한 클래스를 상속하는  자식 클래스도 인터페이스 타입으로 자동 변환될 수 있다.

### 강제 타입변환

`()` 캐스팅 기호를 사용해서 인터페이스 타입을 구현 클래스 타입으로 변환 가능하다. 

- 구현 클래스 변수 = (구현클래스) 인터페이스 변수
- 구현 객체가 인터페이스 타입으로 자동변환되면 인터페이스에 선언된 메소드만 사용 가능하다.
    - 구현 객체만이 가진 메소드를 사용하려면 구현 클래스로 강제 타입변환 해주어야 한다.

### 다형성 제공 (타입체크)

- 현업에서는 주로 상속보다는 인터페이스를 통한 다형성을 구현한다.
- 다형성 ⇒ 사용방법은 동일하지만 다양한 결과가 나오는 성질
- 인터페이스 역시 다형성을 구현하기 위해 재정의와 자동 타입 변환 기능을 이용
- 인터페이스의 추상 메소드 ⇒ 구현 클래스의 재정의
- 재정의된 메소드는 구현 클래스마다 다르다.
- ∴결론 : 구현 객체는 인터페이스 타입으로 자동 타입변환된고, 인터페이스 메소드 호출 시 구현 객체의 재정의된 메소드가 호출되어 다양한 실행 결과를 얻는 다형성을 실현할 수 있다.
- 생성자를 통한 매개변수 주입? 의존성 주입 방식이 권고됨. setter를 통해 의존성 주입보다는 … 아래 내용 참고!

### 의존성 주입(Dependency Injection)이란?

> 의존성 주입은 객체가 자신이 필요로 하는 다른 객체(의존성)를 직접 생성하지 않고 외부에서 주입받는 설계 방식. 이를 통해 객체 간의 결합도는 낮추고, 유연성을 높일 수 있음.
> 

⇒ 예를 들어, `Car` 클래스가 `Engine` 객체를 필요로 할 때, `Car` 클래스 내부에서 `new Engine()`으로 직접 만드는 대신, 외부에서 이미 만들어진 `Engine` 객체를 받아서 사용하는 방식

의존성 주입을 하는 대표적인 방법에는 **생성자(Constructor) 주입**과 **Setter 주입이 있음.**

**1. 생성자 주입(Constructor Injection)**

**객체를 생성할 때 생성자를 통해 의존성을 주입하는 방식**입니다.

```java
// 인터페이스
interface Engine {
    void start();
}

// 구현체
class V6Engine implements Engine {
    @Override
    public void start() {
        System.out.println("V6 엔진이 가동됩니다.");
    }
}

class Car {
    private final Engine engine; // final 키워드 사용

    // 생성자를 통해 Engine 의존성 주입
    public Car(Engine engine) {
        this.engine = engine;
    }

    public void drive() {
        engine.start();
        System.out.println("차가 달립니다.");
    }
}
```

**장점:**

- **객체 불변성(Immutability) 보장:** `final` 키워드를 사용할 수 있어, 객체가 한 번 생성되면 의존성이 바뀌지 않음을 보장합니다. 이는 스레드 안정성을 높이는 데도 도움이 됩니다.
- **안정성:** 객체를 생성하는 시점에 모든 필수적인 의존성이 주입되므로, `NullPointerException`이 발생할 가능성이 줄어듭니다.
- **명확한 역할:** 생성자를 보면 해당 객체가 어떤 의존성들을 필요로 하는지 한눈에 파악할 수 있습니다.

**2. Setter 주입(Setter Injection)**

**Setter 메서드를 통해 의존성을 주입하는 방식**입니다. 객체를 먼저 생성하고, 나중에 Setter 메서드를 호출하여 의존성을 주입합니다.

```java
class Car {
    private Engine engine;

    public Car() {
        // 기본 생성자
    }

    // Setter 메서드를 통해 Engine 의존성 주입
    public void setEngine(Engine engine) {
        this.engine = engine;
    }

    public void drive() {
        if (engine == null) {
            System.out.println("엔진이 없습니다. 운전할 수 없습니다.");
            return;
        }
        engine.start();
        System.out.println("차가 달립니다.");
    }
}
```

**단점:**

- **객체 불일치 상태 발생 가능:** `setEngine()`을 호출하기 전에 `drive()`를 호출하면 `NullPointerException`이 발생할 수 있습니다. 객체가 불안정한 상태로 존재할 수 있습니다.
- **불변성 보장 불가:** `final` 키워드를 사용할 수 없으며, 언제든 `setEngine()` 메서드를 통해 의존성이 변경될 수 있습니다.

### 매개변수의 다형성

- 매개변수 타입을 인터페이스로 선언하면 메소드 호출 시 다양한 구현 객체를 대입할 수 있음.

![image.png](attachment:9bd4ad5e-0020-4c3a-9f71-53eb5a8e9b61:image.png)

## 예외 처리

> 자바에서 오류(error)란
컴퓨터 하드웨어의 고장으로 인하여 응용프로그램 실행 오류를 발생하는 것. 개발자는 할 일이 없다.
> 

> 자바에서 오류(**error**)를 제외한 오류를 예외(**Exception**)라 한다. 개발자가 해결 해야 하는 오류
예외가 발생하면 프로그램은 곧바로 종료되는 점은 에러와 동일하지만 
예외 처리를 통하여 계속 실행 상태를 유지할 수 있다.
> 

### 예외의 구분

일반 예외 (Exception) : **“컴파일러”**가 예외 처리 코드 여부를 검사하는 예외

실행 예외 (Runtime Exception) : **“컴파일러”**가 예외 처리 코드 여부를 검사하지 않는 예외

### 예외 처리

- 자바는 예외가 발생하면 예외 클래스로부터 객체를 생성한다. (feat. 홀매니저 호출! → 사건이 발생하면 내가 처리하는 것이 아니라 누군가에게 위임하는것임)
- 해당 예외 객체가 예외 처리시 사용된다.
- 자바의 모든 에러와 예외 클래스는 `Throwable`을 상속 받아 만들어지고,
- 추가적으로 예외 클래스는 `java.lang.Exception` 클래스를 상속한다.
- 실행 예외는 `RuntimeException` 과 그 subclass에 해당하는데,
- 자바는 자주 사용되는 예외 클래스를 `java.lang` 즉 표준 라이브러리로 제공한다.

> 자바는 예외를 처리시 문제가 발생할 수 있는 문장들을 `try` 블럭으로 묶어놓고 예외 발생 시 예외를 처리하고 프로그램이 정상 종료될 수 있도록 처리해야 한다.
try - catch
try - catch - finally
> 

```java
public class exceptionHandlingEx {
    public static void main(String[] args) {
        System.out.println("[프로그램 시작]");
        try {
            printLength("This is Exception Class");
            printLength(null);
        } catch (Exception e) {
//            System.out.println(e.getMessage()); 
//            e.printStackTrace(); // 개발 시 많이 활용
            System.out.println(e.toString());
        } finally {
            System.out.println("마무리 블럭");
        }

        System.out.println("프로그램 종료");

    }

    private static void printLength(String param) {
        int strLength = param.length();
        System.out.println("전달받은 문자열의 길이" + strLength);
    }
}

```

- **intelliJ 활용법 : 코드 블럭을 드래그해서 묶은 다음 → surround → try-catch 구문을 자동 완성할 수 있다!**

### RuntimeException

```java
public class RuntimeErrorEx {
    public static void main(String[] args) {

        try {
            int[] array = {10, 20, 30};
        System.out.println(array[3]);  // IndexOutOfBoundException
//        System.out.println(12 / 0); // div by zero ArithmeticException

            String str = null;
//        System.out.println(str.toLowerCase()); NullPointerException
            // 정수가 아닌 문자열을 정수로 변환할 때 예외 발생 : NumberFormatException
            String stringNumber = "3.1415928268";
//        int number = Integer.parseInt(stringNumber);
            float number = Float.parseFloat(stringNumber);
            System.out.println(number);

            // ClassCastException : 타입변환은 상위클래스와 하위 클래스간의 상속, 인터페이스 캐스팅 시
            Integer num = 30;
            Object x = num;
//        System.out.println((String)x);

            // InputMismatchException
            // 의도치 않은 입력 오류가 발생할 때 예외
            Scanner in = new Scanner(System.in);
            System.out.println("정수 3개를 입력하세요.");

            int num1 = in.nextInt();

            in.close();
        } catch (NumberFormatException e) {
            e.getMessage();
        } catch (InputMismatchException e1) {
            e1.getMessage();
        } catch (ArrayIndexOutOfBoundsException e2) {
            e2.getMessage();
        } catch (ClassCastException e3) {
            e3.getMessage();
        } catch (ArithmeticException e4) {
            e4.getMessage();
        } catch (RuntimeException e5) {
            e5.getMessage();
        } catch (Exception e6) {
            e6.getMessage();
        } catch (Throwable t) {
            t.getMessage();
        }

    }
}

```

- 예외처리는 subclass ⇒ superclass 확장하며 처리하는 것이 원칙이다!

### 예외 처리 방법

1. try - catch블럭 처리
2. throws 로 처리

### throws 키워드

- 프로그램 실행 중 메서드가 예외를 발생시킬 수 있도록 선언하려면 `throws` 키워드를 사용함.
- 메서드에서 예외가 발생했을 때 해당 메서드가 처리하는 것이 아니라 메서드를 호출한 곳에서 처리를 위임하기 위해 사용함.

```java
package java_advanced_01.day13.exceptionEx;

public class ThrowsEx {
    static void check() throws ArithmeticException {
        System.out.println("내부 메서드");
        int div = 5/0;
    }

    public static void main(String[] args) {
        try {
            check();
        }
        catch(ArithmeticException e) {
            System.out.println("예외발생 " + e);
        }
    }
}

// 실행 결과
// 내부 메서드
// 예외발생 java.lang.ArithmeticException: / by zero
```

```java
import java.util.Scanner;

public class Exception04 {
    static void check(int num) throws NumberFormatException {
        if (num < 0) // 입력 받은 수가 0보다 작을 때 throw로 예외 발생
            throw new NumberFormatException("0보다 작습니다.");
        else
            System.out.println(num);
    }

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        System.out.println("숫자를 입력하세요.");
        int num = s.nextInt();

        try {
            if (num < 0)
                throw new NumberFormatException("0보다 작습니다."); // 예외 발생
            else
                System.out.println(num);

            check(num);
        } catch (NumberFormatException e) { // 예외 처리
            System.out.println("예외 발생 " + e);
        }
    }
}

숫자를 입력하세요.
-1
예외 발생 java.lang.NumberFormatException: 0보다 작습니다.
```

### 사용자 정의 예외

- 사용자가 새로운 예외 클래스를 만들어서 이용할 수 있는 방법
- java.lang 패키지의 Exception 예외 클래스를 상속받아 작성
- 사용자 정의 예외 클래스에 대한 생성자를 정의하고(필수는 아님!)
- toString() 메소드를 재정의하여 catch 블록에서 사용자 정의 메시지를 표시할 수 있음
- 사용자 정의 예외 클래스를 만들고 `throw` 키워드로 예외를 발생시켜 호출함.

```java
public class MyException01 extends Exception{
    public MyException01(String s) {
        super(s);
    }
}
```

```java
public class MyExceptionTest {
    void check(int weight) throws MyException01 {
        if (weight < 100) {
            throw new MyException01("MyException01 클래스 호출입니다.");
        }
    }

    public static void main(String[] args) {
        MyExceptionTest obj = new MyExceptionTest();
        try {
            obj.check(50);
        } catch (MyException01 e) {
            System.out.println("예외 처리입니다.");
            System.out.println(e.getMessage());
        }
    }
}

// 실행 결과
// 예외 처리입니다.
// MyException01 클래스 호출입니다.
```