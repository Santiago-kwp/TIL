# 25.08.19.(화) 인터페이스, 익명 클래스 및 람다식

**Comparable 인터페이스 방법**

자바에서는 같은 타입의 인스턴스를 비교할 때 해당 클래스가 Comparable 인터페이스를 구현 : compareTo() 메소드 오버라이딩

Comparator 인터페이스 방법

익명 객체를 이용하여 좀 더 유연하게 다양한 속성을 이용해서 정렬 할 수 있다.

만약 나이순으로 정렬했는데, 나이가 같은 사람이 있다. 추가적으로 이름순으로 정렬기준을 제시해 주어야 한다.

객체의 여러 속성을 이용하여 정렬하려면 Comparator 인터페이스 `comparing()`, `thenComparing()` 메소드 체이닝  방식으로 구현할 수 있다. 

```java
System.out.println("---------이름 순 오름차순 후 같은 이름이면 나이순으로 정렬 ---------");
Arrays.sort(users, Comparator.comparing(User::getName).thenComparing(User::getAge));
for(User user : users) {
		System.out.print(user.getName() + ": " + user.getAge() + ", ");
}
```

- 메소드 참조 방식으로 구현되는 것을 볼 수 있다. (`User::getName`, `User::getAge`)

### 익명 클래스 (Anonymous Class)

내부(inner) 클래스의 일종으로 이름이 없는 클래스

프로그램에서 일시적으로 한번만 사용되고 버려지는 객체(일회용)

어떤 클래스의 자원을 상속 받아 재정의하여 사용하기 위해서는 먼저 자식이 될 클래스를 만들고 `extends`  후 객체 인스턴스 초기화가 가능하다.

필요성 

- 클래스 정의 없이 메소드 내에서 바로 클래스를 생성하여 인스턴스화 할 수 있다.
- 단 한번만 사용할 수 있고, 익명으로 정의된 클래스는 일회성으로 사용되고 버려짐.
- 이는 자식 클래스가 한번 만 사용되는 자료형이라면 부모 클래스에 정의하는 것보다는 지역변수처럼, 익명 클래스로 정의하고 스택이 끝나면 삭제되도록 하여 유지보수나 메모리 관리 측면에서 이점을 얻을 수 있다.
- 코드의 양을 줄여 가독성을 높이는 방법 중 하나이다.
- UI 이벤트 처리, 스레드 객체, 이벤트 루프

**사용 시 주의점**

익명클래스 방식은 오버라이딩한 메소드만 사용이 가능하다. 

새로 정의한 메소드는 외부에서는 사용이 불가능하다. 새로 정의한 메소드는 외부 스코프에서 호출될 수 없고, 익명 클래스 내에서만 호출이 가능하다.

```java
class Animal {
    public String eat() {
        return "맛있게 먹습니다.";
    }
}
public class Main {
    public static void main(String[] args) {
        Animal dog = new Animal() {
            @Override
            public String eat() {
                System.out.println(run()); // 가능
                return "강아지 멍멍";
            }
            public String run() {
                return "강아지가 뛴다.";
            }
        };
        
        dog.eat(); // 가능
//        dog.run(); // 불가능
    }
    
}
```

익명 객체 가장 많이 사용

인터페이스 익명 구현 객체 (메소드의 아규먼트로 일회성 객체를 넘겨주는 방법)

### 익명객체를 인터페이스에서 활용하는 방법

익명 객체(Anonymous Object)는 클래스 이름 없이 **인터페이스를 즉석에서 구현**하거나 **기존 클래스를 상속**받을 때 사용하는 객체입니다. 주로 한 번만 사용되는 객체를 간결하게 정의할 때 유용하며, 특히 **이벤트 핸들러**나 **콜백 함수**를 구현할 때 많이 쓰입니다.

---

### 기본 활용법

익명 객체를 인터페이스에서 활용하는 가장 기본적인 방법은 다음과 같습니다.

```java
interface MyInterface {
    void myMethod();
}

public class Main {
    public static void main(String[] args) {
        // 익명 객체를 사용하여 MyInterface 구현
        MyInterface myObject = new MyInterface() {
            @Override
            public void myMethod() {
                System.out.println("myMethod() from an anonymous object");
            }
        };

        myObject.myMethod();
    }
}
```

이 코드는 `MyInterface`라는 인터페이스를 정의하고, `new MyInterface() { ... }` 문법을 사용하여 **이름 없는 객체**를 만들고 `myMethod()`를 구현합니다.

---

### 특징 및 주의사항

- **일회성 사용:** 익명 객체는 이름이 없으므로 재사용할 수 없습니다. 따라서 한 번만 사용되는 곳에 적합합니다.
- **지역 변수 접근:** 익명 객체 내에서 외부의 지역 변수를 사용할 수 있습니다. 단, 이 변수는 **`final`*이거나 **사실상 `final`*이어야 합니다. 즉, 한 번 초기화된 후에는 값을 변경할 수 없습니다.
- **간결성:** 복잡한 이벤트 리스너를 정의할 때처럼, 짧은 코드로 특정 메서드를 구현할 때 코드의 양을 크게 줄일 수 있습니다.
- **람다식과의 관계:** 익명 객체는 **추상 메서드가 하나뿐인 인터페이스(함수형 인터페이스)**에서 **람다식(Lambda Expression)**으로 대체될 수 있습니다. 람다식은 익명 객체보다 훨씬 더 간결합니다.

**예시:**

```java
// 람다식으로 변경
MyInterface myLambda = () -> System.out.println("myMethod() from a lambda expression");
myLambda.myMethod();
```

익명 객체는 람다식의 등장으로 사용 빈도가 줄었지만, 여러 개의 추상 메서드를 가진 인터페이스를 구현해야 하거나 복잡한 초기화 로직이 필요한 경우에는 여전히 유용하게 사용됩니다.

람다식은 Java8에 도입되었고, 

함수형 프로그래밍 구조를 다룰 때 개발자가 자바 코드를 작성하는 데 변화를 가져옴

`@FunctionalInterface`

단일 메서드 인터페이스(함수형 인터페이스)

인터페이스가 단 하나의 추상메소드를 가지고 있다. 

인스턴스를 보다 명확하고 간결하게 표현할 수 있는 메소드를 제공합니다. 

**람다표현식이란?** 

정의 : 람다 표현식은 **함수형 인터페이스를 인스턴스화 하는데 사용되는 익명함수**

자바에서는 함수형 인터페이스는 하나의 추상메소드만 포함하는 인터페이스이다.

람다 구현식은 이 단일 메소드의 구현을 제공할 수 있어, 보단 간결하고 통합된 코드 베이스를 가능하게 한다.

**함수형 인터페이스**

자바는 람다 표현식으로 구현할 수 있는 타입을 정의하기 위해 함수형 인터페이스 개념을 사용한다.

`java.util.function` 패키지에서 다양한 수와 타입의 인수를 받을 수 있는 함수형 인터페이스를 제공하고 있다.

**주요 함수형 인터페이스**

1. Predicate<T> : 하나의 인수에 대한 boolean 값을 가지는 함수

`Predicate<String> isEmpty = str -> str.isEmpty();`

1. Function<T,R>  : T 타입의 인수를 받아 R 타입의 결과를 반환하는 함수

`Function<String, Integer> length = str -> str.length();`

1. Consumer<T> : 단일 입력을 받아 수락(사용)하고 결과를 반환하지 않는 함수
2. Supplier<T> : 값을 반환하는 메서드를 제공하는 결과의 공급자 함수

`Supplier<String> greet = () -> "Hello, lambda";` 

1. BiFunction<T, U, R> : 두 개의 아규먼트(T, U)를 받아 결과를 생성하는 함수

간결한 (보일러플레이트 코드를 줄여준다.) 별도의 클래스나 익명 클래스를 만들 필요없이 간단한 콜백이나 함수형 인터페이스를 구현할 수 있게 한다.

함수형 인터페이스가 보일러플레이트 코드를 줄여준다는 것은, 불필요한 코드를 최소화하여 더 간결하고 읽기 쉬운 코드를 작성할 수 있게 해준다는 뜻입니다.

### 함수형 인터페이스의 핵심 역할

함수형 인터페이스는 단 하나의 추상 메서드만 가진 인터페이스를 말합니다. 이 특성 때문에 람다 표현식(Lambda Expressions)과 함께 사용할 수 있으며, 이것이 보일러플레이트 코드를 줄이는 핵심적인 이유입니다.

---

### 보일러플레이트 코드란?

**보일러플레이트(Boilerplate) 코드**는 반복적으로 작성해야 해서 실질적인 로직과는 관련 없는 코드를 의미합니다. 예를 들어, 자바 8 이전에는 간단한 콜백 함수를 사용하려면 다음과 같은 과정을 거쳐야 했습니다.

1. **인터페이스 정의**: 콜백 기능을 위한 인터페이스를 만듭니다.

```java
interface MyCallback {
    void doSomething(String message);
}
```

1. **익명 클래스 생성**: 이 인터페이스를 구현하기 위해 새로운 클래스 파일을 만들거나, 주로 **익명 클래스**를 사용해야 했습니다.Java

```java
MyCallback callback = new MyCallback() {
    @Override
    public void doSomething(String message) {
        System.out.println("콜백 실행: " + message);
    }
};
```

1. **호출**: 이 객체를 메서드에 전달하여 사용합니다.Java

```java
someMethod(callback);
```

위 코드에서 `new MyCallback()`, `@Override`, `public void doSomething(String message)` 같은 부분은 실제 하고 싶은 일(`System.out.println(...)`)을 위해 반드시 작성해야 하는 "껍데기" 코드입니다.

---

### 함수형 인터페이스와 람다 표현식으로 코드 간소화

자바 8부터 도입된 **함수형 인터페이스**와 **람다 표현식** 덕분에 위와 같은 코드를 훨씬 간결하게 만들 수 있습니다.

- **람다 표현식**은 익명 클래스의 대체제로, 메서드를 간단한 식 형태로 표현할 수 있게 해줍니다.

만약 `MyCallback` 인터페이스가 `@FunctionalInterface` 어노테이션이 붙은 함수형 인터페이스라면, 다음과 같이 람다 표현식으로 훨씬 간결하게 표현할 수 있습니다.

```java
// 별도의 클래스나 익명 클래스 없이 바로 람다 표현식으로 구현
MyCallback callback = (message) -> System.out.println("콜백 실행: " + message);

// 혹은 더 줄여서
someMethod((message) -> System.out.println("콜백 실행: " + message));
```

위 코드를 보면, 실제 실행하고 싶은 로직인 `System.out.println(...)`만 남기고 `new MyCallback()`, `@Override`, 메서드 이름, 타입 선언 등의 코드가 모두 사라졌습니다. 이것이 바로 함수형 인터페이스가 **별도의 클래스나 익명 클래스를 만들 필요 없이** 간단한 콜백을 구현하여 **보일러플레이트 코드를 줄여준다**는 의미입니다.

결론적으로, 함수형 인터페이스는 람다 표현식을 사용할 수 있는 **조건**을 제공하고, 람다 표현식은 그 조건을 이용해 **간결한 코드**를 작성할 수 있게 해주는 **문법적 설탕(Syntactic Sugar)**이라고 볼 수 있습니다.

### 보일러 플레이트 용어의 유래 📰

- *보일러플레이트(boilerplate)**라는 단어는 원래 19세기 후반에 신문사들이 미리 만들어 둔 **주형(鑄型) 철판**을 의미했습니다. 이 철판에는 날씨 정보, 스포츠 경기 결과, 광고, 유명 작가의 칼럼 등 여러 신문에서 반복적으로 사용되는 **상용구(常用句)**가 새겨져 있었습니다.

신문사들은 이 철판을 받아 인쇄기에 넣고 필요한 내용만 추가하여 쉽게 신문을 발행할 수 있었습니다. 이렇게 하면 매번 똑같은 내용을 처음부터 다시 주조할 필요 없이 시간과 비용을 크게 절약할 수 있었죠.

### 프로그래밍 용어로의 전환 💻

이러한 개념이 컴퓨터 프로그래밍 분야로 넘어오면서, **"별다른 수정 없이 반복적으로 복사해 사용하는 코드"**를 "보일러플레이트 코드"라고 부르게 되었습니다. 즉, 실질적인 로직을 구현하기 위해 반드시 필요하지만, 매번 똑같은 형태로 작성해야 하는 관습적인 코드를 가리키는 말입니다.

예를 들어, 자바에서 `getter`나 `setter` 메서드, 그리고 이전 답변에서 언급된 익명 클래스 선언부가 대표적인 보일러플레이트 코드에 해당합니다.