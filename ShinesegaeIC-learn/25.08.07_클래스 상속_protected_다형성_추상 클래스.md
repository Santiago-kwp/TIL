# 25.08.07.(목) 상속, protected, 다형성 및 추상 클래스

## 상속

- 상속 : 컴퓨터 관점에서 상속이란 부모 클래스의 메모리에 대한 확장 과정임
    - 자식 클래스가 부모 클래스의 속성과 메소드를 물려받아 사용하는 관계
    - 코드의 재사용성을 높이고, 클래스 간의 계층적인 관계를 구축하는 객체 지향 프로그래밍의 핵심 원리
    - **독립적인 메모리 할당**: 자식 클래스의 인스턴스를 생성하면 **부모 클래스의 멤버 변수와 자식 클래스의 멤버 변수 모두를 포함하는 새로운 메모리 공간이 할당**돼요.
    메모리를 "공유"하는 것이 아니라, 부모 클래스의 '청사진(blueprint)'을 바탕으로 자식 클래스 인스턴스에 필요한 메모리를 새롭게 할당하는 것이죠.
    - **메서드 재사용**: 메서드(동작)의 경우, **메서드 자체는 메모리 상에 한 번만 존재**해요.
    자식 클래스 인스턴스가 부모 클래스의 메서드를 호출하면, 이 메서드가 정의된 동일한 메모리 위치를 참조하게 되므로, 이는 "메서드 코드의 공유"라고 볼 수 있어요.
    
    자식 클래스가 **오버로딩된 생성자**를 명시적으로 정의하면, 컴파일러는 더 이상 **기본 생성자를 자동으로 생성해주지 않기** 때문에 직접 코딩해줘야 함.
    
    ---
    
    ### **생성자의 기본 원리**
    
    클래스에 생성자를 하나도 명시적으로 선언하지 않으면, 자바 컴파일러는 자동으로 **인자가 없는 기본 생성자(default constructor)**를 추가해 줍니다. 이 기본 생성자는 부모 클래스의 인자 없는 생성자를 호출하는 `super()` 코드를 내부에 포함하고 있음.
    
    ---
    
    ### **생성자 오버로딩과 기본 생성자**
    
    자식 클래스에 인자를 받는 생성자(예: `public Child(String name)`)를 하나라도 직접 작성하면, 컴파일러는 더 이상 기본 생성자를 자동으로 만들어주지 않습니다. 이 때문에 인자 없이 객체를 생성하려고 하면 컴파일 오류가 발생함.
    
    **예시**
    
    ```java
    // 부모 클래스
    class Parent {
        public Parent() {
            System.out.println("Parent 기본 생성자 호출");
        }
    }
    
    // 자식 클래스
    class Child extends Parent {
        // 인자를 받는 생성자를 작성하면
        public Child(String name) {
            System.out.println("Child 생성자 호출: " + name);
        }
        
        // 이 코드가 없으면 컴파일 에러 발생
        // public Child() {
        //     super(); // 부모의 기본 생성자를 명시적으로 호출
        //     System.out.println("Child 기본 생성자 호출");
        // }
    }
    
    public class Main {
        public static void main(String[] args) {
            // Child child1 = new Child(); // <-- 이 줄은 컴파일 에러 발생
            
            Child child2 = new Child("철수"); // 이 코드는 정상 실행
        }
    }
    ```
    
    위 코드에서 `new Child()`를 호출하려면, 인자가 없는 `Child()` 생성자를 직접 작성해 줘야 한다.
    

### **부모 생성자 호출**

- **자식 객체를 생성하면 부모 객체가 먼저 생성된 다음에 자식 객체가 생성**
    - 자식 클래스의 생성자 첫 행에 이 명령어가 있어야 한다.
    - 자식 클래스의 생성자가 부모 클래스의 생성자를 명시적으로 호출하지 않으면 자바 컴파일러는 부모 클래스의 매개변수가 없는 생성자를 자동으로 호출한다.
    - 이때, 부모 클래스에 매개변수가 없는 생성자가 존재하지 않으면 컴파일 타임 오류가 발생
- `super()` : 부모 클래스의 기본 생성자가 호출된다. → 힙 영역에 부모 클래스의 필드와 메소드가 생성(할당)된다.
- `this.model = model` : `model`은 스택 영역의 지역변수로 임시 저장용이고, `this.model` 은 객체의 영역에 있는 데이터로 `this.model = model` 은 힙의 영역에 스택 영역에 저장된 데이터를 저장시켜주는 것이다. -

### 메소드 재정의

> 상속된 메소드를 서브클래스에서 재정의하는 것을 의미한다. 
조건 : 부모의 시그니처 그대로 사용해야 하고, 구현부만 재정의하여 사용한다.
해당 슈퍼클래스(부모)의 메소드는 숨겨지고, 서브 (자식) 메소드가 우선적으로 사용된다.
> 

규칙 : 

조건 : 부모의 시그니처 그대로 사용해야 한다. (리턴타입, 메소드 이름, 매개변수) 동일해야 한다.
접근 제한을 더 강하게 오버라이딩 할 수 없다. (public → private (X))

`Ctrl + O` : 메소드 오버라이딩 선택할 수 있게 표시해주는 IntelliJ 단축키 (`Alt + Insert` → Method Overriding 해도 됨)

`@Override` : 어노테이션으로 컴파일 시 컴파일러가 해당 메소드가 슈퍼클래스의 메소드를 오버라이딩한 것임을 알려주는 기능. → 정확히 오버라이딩 되었는지 확인해줌.

### final 클래스와 final 메소드

- 필드 선언 시 `final` : 상수로 초기값을 설정 후 값을 변경할 수 없다.
- 클래스 선언 시 `final` : 최종 클래스이므로 더 이상 상속할 수 없는 클래스가 된다. → `extends` 불가. 자식 클래스가 없음
    - Ex. `System, String, Scanner()`  등
- 메소드 선언 시 `final` : 최종 메소드이므로 더 이상 오버라이딩 할 수 없다. → 부모 클래스에서 final 메소드로 지정하면 자식 클래스에서 오버라이딩 할 수 없다.

### Protected 접근 제한자

- 같은 패키지 내에서의 protected의 접근 A, B  클래스 가능
    - 같은 패키지에 속한 클래스들은 상속 관계가 아니어도 `protected` 멤버에 자유롭게 접근할 수 있음.
    - 클래스 `A`와 `B`가 같은 패키지에 있다면, `B` 클래스는 `A` 클래스의 `protected` 필드, 생성자, 메서드에 직접 접근할 수 있습니다. 마치 `default` 접근 제한자처럼 작동함.
- 다른 패키지에서의 `protected`의 접근은 자식 클래스 (D) 생성자에서 `super()` 생성자 호출 메소드를 통해서 A의 자식 클래스이므로 A 의 protected 필드, 생성자, 메소드에 접근할 수 있다.
→  `new`  연산자를 사용해서 `protected`로 제한된 부모의 생성자를 직접 호출은 불가 하다. (왜냐면 일반적인 인스턴스 생성이므로)
    - `protected` 멤버를 다른 패키지에서 접근하려면 **반드시 상속 관계를 통해야만** 함.
    - 자식 클래스(예: `D`)는 부모 클래스(예: `A`)와 다른 패키지에 있어도, 상속받은 `protected` 멤버에 직접 접근할 수 있습니다. (`this` 나 `super` 를 통해)
- **생성자 호출에 대한 정확한 이해**
    - `super()`를 통한 생성자 호출은 `protected` 멤버 접근의 대표적인 예시입니다. 자식 클래스(`D`)의 생성자에서 부모 클래스(`A`)의 `protected` 생성자를 `super()`로 호출하는 것은 허용됩니다.
    - **`new` 연산자를 통한 직접 호출 불가**: 다른 패키지에 있는 부모 클래스가 `new A()`와 같이 `protected` 생성자를 직접 호출하는 것은 불가능합니다. 이는 상속 관계가 아니므로 허용되지 않습니다.
    
    **1. 상속 관계에서의 접근**
    
    - **자식 클래스 인스턴스**는 **상속을 통해 물려받은** 부모의 `protected` 멤버에 접근할 수 있습니다.
    - 이때의 접근은 `this` 또는 `super` 키워드를 통해 이루어집니다.
    - 이것이 바로 `protected`가 다른 패키지에서 상속받은 자식에게 접근을 허용하는 방식입니다.
    
    ```java
    package com.child;
    
    import com.parent.Parent;
    
    // 상속 관계 성립
    public class Child extends Parent { 
        void accessMethod() {
            // 'this'를 통해 상속받은 protected 필드에 접근
            System.out.println(this.protectedField); // 가능!
        }
    }
    ```
    
    **2. 일반적인 인스턴스 접근**
    
    - 자식 클래스 안에서 `new Parent()`로 생성한 객체는 **단순히 부모 클래스 타입의 새로운 인스턴스**일 뿐입니다.
    - 이 인스턴스는 상속 관계를 통해 물려받은 객체가 아니므로, `protected` 멤버에 접근할 수 없습니다.
    
    ```java
    package com.child;
    
    import com.parent.Parent;
    
    public class Child extends Parent {
        void anotherMethod() {
            // 일반적인 Parent 인스턴스 생성
            Parent someParent = new Parent(); 
    
            // 상속 관계가 아닌, 독립적인 인스턴스이므로 접근 불가
            // System.out.println(someParent.protectedField); // 컴파일 에러!
        }
    }
    ```
    

### 자동 타입변환

- 자식은 부모의 필드와 메소드를 상속받기 때문에 부모와 동일하게 취급될 수 있다.
    - 고양이가 동물의 특징과 기능을 상속받았다면, ‘고양이는 동물이다.’ 라는 관계가 성룁된다.
    
    ```java
    class A {}
    class B extends A{}
    class C extends A{}
    class D extends B{}
    class E extends C{}
    
    public class PromotionExample {
    	public static void main(String[] args) {
    
    		B b = new B();
    		C c = new C();
    		D d = new D();
    		E e = new E();
    
    		A a1 = b; // 상속관계이므로 b객체변수에 저장된 주소값은 부모인 A타입의 a1에 담을 수 있다.
    		A a2 = c;
    		A a3 = d;
    		A a4 = e;
    
    		B b1 = d;
    //		B b2 = e; /
    		C c1 = e;
    //		C c2 = d; // 나의 부모타입으로만 자동타입변환이 된다(promotion). 상속관계가 아니다.
    	}
    }
    ```
    
- 상속 관계는 연관관계(association) 이다. Is - A 관계이다.

### 강제 타입변환

- 부모 타입은 자식 타입으로 자동 변환되지 않음. 대신 캐스팅 연산자로 강제 타입 변환 가능
- 자식타입 변수 = (자식타입) 부모타입객체; () 캐스팅연산자 ⇒ 강제 타입변환
    - Ex. `Parent p = new Child();` → Child의 메소드, 필드에 접근할 수 없음
    - `Child c = (Child) p;` 해줘야 가능
    - 자식 객체가 부모 타입으로 자동변환하면 부모타입에 선언된 필드와 메서드만 사용가능하다는 제약사항이 따른다.
    - 만약, 자식타입에 선언된 필드와 메서드가 필요하다면 강제 타입 변환을 하여 다시 자식 타입으로 변환해야만 자식타입에서 제공하는 필드를 사용할 수 있다.
    
    ```java
    package javabasic_02.day11.inheritance.sec08.shape;
    
    public class M01 {
        
        // 사각형, 삼각형, 원 클래스는 서로 다른 타입이어서 각각 타입을 정의해서 같은 타입끼리 묶어서 관리하겠다.
        public static void main(String[] args) {
            Rectangle[] rectangles = new Rectangle[4];
            rectangles[0] = new Rectangle();
            rectangles[1] = new Rectangle();
            rectangles[2] = new Rectangle();
            rectangles[3] = new Rectangle();
            
            Triangle[] triangles = new Triangle[5];
            for (int i = 0; i < triangles.length; i++) {
                triangles[i] = new Triangle();
            }
            
            Circle[] circles = new Circle[3];
            for (int i = 0; i < circles.length; i++) {
                circles[i] = new Circle();
            }
            
            // Rectangle extends Shape, Triangle extends Shape, Circle extends Shape
            Shape[] shapes = new Shape[4];
            shapes[0] = rectangles[0];
            shapes[1] = rectangles[1];
            shapes[2] = triangles[2];
            shapes[3] = circles[2];
            
            Circle circle = (Circle) shapes[3]; // 다운 캐스팅
            
            
        }
    }
    // 하나의 자료형 Shape으로 관리하니 코드량도 적어지고 가독성도 좋아지고 유지보수성도 좋아집니다.
    // 자식 클래스에서만 있는 고유 메소드를 실행하려면 업캐스팅한 객체를 다시 자식 클래스로 다운 캐스팅 해줘야만 한다.
    
    ```
    

### 다형성

- 사용방법은 동일하지만 실행 결과 다양하게 나오는 성질
- 자동차의 부품을 교환하면 성능이 다양하게 나온다. 즉 객체는 부품(Component)이라고 보자
- 프로그램을 구성할 때 객체를 바꾸면 프로그램의 실행 성능이 달라진다.

> “객체사용 방법이 동일하다” 문장의 의미 ⇒ 동일한 메소드를 가지고 있다.
자동차의 바퀴는 필수이지만, 타이어를 다양하게 바꾸면 성능이 달라질 수 있다.
> 
- 필드 다형성

```java
package javabasic_02.day11.inheritance.sec08.exam01;

public class CarExample {
	public static void main(String[] args) {
		//Car 객체 생성
		Car mydreamCar = new Car();

		//Tire 객체 장착 및 메소드 실행
		mydreamCar.tire = new Tire();
		mydreamCar.run();

		//KumhoTire 객체 장착 = 부품 injection
		mydreamCar.tire = new KumhoTire();
		mydreamCar.run();

		//HankookTire 객체 장착
		mydreamCar.tire = new HankookTire();
		mydreamCar.run();

	}
}
```

- 매개변수 다형성
    - 필드보다는 메소드를 호출할 때 발생한다. 메소드가 클래스 타입의 매개변수를 가지고 있을 경우, 호출 시  동일한 타입의 객체를 제공하는 것이 옳지만, 자식 객체를 제공할 수 도 있다.
    - 주로 필드 다형성보다는 매개변수 다형성이 주로 사용됨.
    
    ```java
    package javabasic_02.day11.inheritance.sec08.exam02;
    
    public class DriverExample {
    	public static void main(String[] args) {
    		//Driver 객체 생성
    		Driver driver = new Driver();
    
    		//매개값으로 Bus 객체를 제공하고 driver() 메소드 호출
    		Bus bus = new Bus();
    		driver.drive(bus);
    
    		//매개값으로 Taxi 객체를 제공하고 driver() 메소드 호출
    		Taxi taxi = new Taxi();
    		driver.drive(taxi);
    
    	}
    }
    
    package javabasic_02.day11.inheritance.sec08.exam02;
    
    public class Driver {
    	//메소드 선언(클래스 타입의 매개변수를 가지고 있음)
    
        public void drive(Vehicle vehicle){
            vehicle.run();
        }
    
    }
    
    package javabasic_02.day11.inheritance.sec08.exam02;
    
    public class Vehicle {
    	//메소드 선언
        public void run(){
            System.out.println("달립니다.");
        }
    
    	}
    	
    	package javabasic_02.day11.inheritance.sec08.exam02;
    
    public class Taxi extends Vehicle {
    	//메소드 재정의(오버라이딩)
        @Override
        public void run() {
            System.out.println("택시가 달린다.");
        }
    
    }
    ```
    

### 객체 타입 확인 : 연산자 instanceof (객체 타입 비교 연산자)

> 내가 원하는 타입이 들어왔는지 확인이 필요하다
매개변수의 다형성에서 실제로 어떤 객체가 매개값으로 제공되었는지의 여부를 확인해야 한다.
> 
- `boolean result = 객체 instanceof 타입;`

```java
public void method(Parent parent) {
		if (parent instanceof Child){
				Child child = (Child) parent;
		}
}
```

- java12 부터 줄어듦

```java
public void method(Parent parent) {
		if (parent instanceof Child child){
				child.method3();
		}
}
```

### 추상 클래스

> 추상(abstract)은 실체 간에 공통되는 특성을 추출하는 과정을 뜻한다. 
공통되는 특성 ⇒ 공통적인 필드나 메서드를 추출해서 선언한 클래스를 추상 클래스라 한다.
추상 클래스는 실체 클래스의 부모 역할을 한다.
실체 클래스는 추상 클래스를 상속해서 공통적인 필드나 메소드를 물려받아 사용할 수 있다.
> 
- 장기 프로젝트 등산을 한다면 베이스 캠프 개념 → 필요한 것들만 모아 놓음
- `Animal animal = new Animal();` (X) → 추상클래스는 인스턴스 (메모리 할당)할 수 없다.
- 추상 클래스는 새로운 실체 클래스를  만들기 위한 부모 클래스로만 사용된다.
- `public abstract class 클래스명 {}` 으로 선언한다.