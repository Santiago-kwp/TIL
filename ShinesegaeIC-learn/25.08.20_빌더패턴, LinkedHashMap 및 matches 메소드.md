# 25.08.20.(수) 게시판 프로젝트 - 빌더 패턴, LinkedHashMap, matches 메소드(feat. 정규표현식)

![Board_proj_v1.png](attachment:8ddcf2e2-a409-4a16-b3af-a2eb8925ae01:Board_proj_v1.png)

Lombok의 빌더 어노테이션 활용 → 보드 객체 만들기

```java
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Date;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Board {
    private int bno; // 글번호
    private String btitle; // 글제목
    private String bcontent; // 글 내용
    private String bwriter;  // 글쓴이
    private Date bdate;     // 글쓴 날짜
}
```

### 빌더 패턴이란?

> 빌더 패턴은 객체를 생성하는 복잡한 과정을 분리하여, 동일한 생성 절차로 다양한 표현의 객체를 만들 수 있도록 하는 디자인 패턴입니다. 객체의 필드가 많거나 선택적(optional) 필드가 많을 때 유용하며, 생성자의 파라미터가 너무 많아지는 **"텔레스코핑 생성자(telescoping constructor)"** 문제를 해결할 수 있습니다.
> 

---

### 예시

고객 정보를 저장하는 `Customer` 데이터 클래스를 빌더 패턴으로 구현해 보겠습니다.

### 1. `Customer` 클래스 정의

```java
public class Customer {
    private final String firstName;
    private final String lastName;
    private final String email;
    private final String phoneNumber; // 선택적 필드
    private final String address;     // 선택적 필드

    // ⛔️ 생성자를 private으로 만들어 외부에서 직접 인스턴스화하는 것을 막습니다.
    private Customer(Builder builder) {
        this.firstName = builder.firstName;
        this.lastName = builder.lastName;
        this.email = builder.email;
        this.phoneNumber = builder.phoneNumber;
        this.address = builder.address;
    }

    // ✨ 필수 필드와 선택적 필드를 모두 가진 클래스를 생성합니다.
    public static class Builder {
        // 필수 필드
        private final String firstName;
        private final String lastName;
        private final String email;

        // 선택적 필드
        private String phoneNumber;
        private String address;

        public Builder(String firstName, String lastName, String email) {
            this.firstName = firstName;
            this.lastName = lastName;
            this.email = email;
        }

        public Builder phoneNumber(String phoneNumber) {
            this.phoneNumber = phoneNumber;
            return this;
        }

        public Builder address(String address) {
            this.address = address;
            return this;
        }

        public Customer build() {
            return new Customer(this);
        }
    }

    @Override
    public String toString() {
        return "Customer{" +
                "firstName='" + firstName + '\'' +
                ", lastName='" + lastName + '\'' +
                ", email='" + email + '\'' +
                ", phoneNumber='" + phoneNumber + '\'' +
                ", address='" + address + '\'' +
                '}';
    }
}
```

**`Builder` 클래스**는 `Customer` 클래스 안에 정적(static) 멤버 클래스로 정의하는 것이 일반적입니다. 이렇게 하면 `Customer` 클래스의 `private` 생성자에 접근할 수 있습니다. 각 메서드(`phoneNumber`, `address`)는 `this`를 반환하여 메서드 체이닝이 가능하게 합니다.

---

### 2. 사용 예시

```java
public class Main {
    public static void main(String[] args) {
        // ✨ 필수 필드만 사용하여 Customer 객체 생성
        Customer customer1 = new Customer.Builder("John", "Doe", "john.doe@example.com")
                                        .build();
        System.out.println(customer1);
        
        System.out.println("----------------------------------------");

        // ✨ 모든 필드를 사용하여 Customer 객체 생성
        Customer customer2 = new Customer.Builder("Jane", "Smith", "jane.smith@example.com")
                                        .phoneNumber("123-456-7890")
                                        .address("123 Builder St, New York")
                                        .build();
        System.out.println(customer2);
    }
}
```

`Customer` 객체를 생성할 때 `new Customer.Builder(...)`로 빌더 인스턴스를 만들고, 원하는 선택적 메서드를 호출한 다음 마지막에 **`.build()`**를 호출합니다. 이 방식은 코드를 훨씬 더 읽기 쉽고 안전하게 만듭니다.

## 빌더 패턴의 주요 사용 사례

---

### 1. 객체의 생성자가 너무 복잡할 때 (Telescoping Constructor)

생성자 오버로딩을 통해 여러 개의 생성자를 만들다 보면 코드가 복잡해지고 가독성이 떨어집니다. 예를 들어, 사용자 정보를 담는 객체가 이름, 이메일은 필수지만 전화번호, 주소, 회사 정보는 선택적일 경우, 모든 경우의 수를 위한 생성자를 만드는 것은 비효율적입니다. 빌더 패턴을 사용하면 이러한 복잡성을 해소하고, 코드를 더 깔끔하게 유지할 수 있습니다.

### 2. 불변 객체(Immutable Object)를 만들 때

객체가 한 번 생성된 후에는 상태를 변경할 수 없는 불변 객체는 동시성(concurrency) 문제에 강하고 예측 가능성이 높습니다. 빌더 패턴은 객체를 단계적으로 설정한 후, `build()` 메서드를 호출하는 시점에 **모든 필드가 한 번에 초기화된 불변 객체**를 반환할 수 있도록 해줍니다.

### 3. 유연한 객체 생성이 필요할 때

필드의 순서나 개수에 상관없이 객체를 생성해야 할 때 유용합니다. 메서드 체이닝 방식을 사용하므로, 어떤 필드를 설정할지 선택하고 원하는 순서대로 호출할 수 있습니다.

### 4. 다양한 설정이 가능한 객체를 생성할 때

라이브러리나 프레임워크에서 **설정 객체(configuration object)**를 만들 때 자주 사용됩니다. 예를 들어, HTTP 요청을 보내는 클라이언트 객체를 만들 때, 타임아웃, 헤더, 인증 방식 등 여러 가지 설정을 유연하게 지정할 수 있도록 빌더 패턴을 적용합니다.

## 주로 사용되는 애플리케이션

- **복잡한 설정이 필요한 라이브러리:** Spring Framework의 `RestTemplate.Builder`나 `MockMvc.builder()`처럼, 다양한 설정 옵션을 제공하는 라이브러리에서 빌더 패턴을 많이 볼 수 있습니다.
- **데이터베이스 연결 풀 관리:** 연결 설정 객체를 빌더 패턴으로 구현하여, 사용자가 필요한 옵션만 지정하도록 합니다.
- **GUI 애플리케이션:** 복잡한 UI 요소를 구성할 때, 각 속성을 빌더를 통해 설정하고 최종적으로 객체를 생성하는 데 사용됩니다.

### LinkedHashMap

Java의 **LinkedHashMap**은 `HashMap`과 `LinkedList`의 기능을 결합한 자료구조입니다. 주요 특징은 **삽입 순서를 유지**한다는 점입니다.

---

## 🔍 주요 특징

### 1. 삽입 순서 보장 (Insertion Order)

`HashMap`은 요소의 순서를 보장하지 않지만, `LinkedHashMap`은 요소가 추가된 순서대로 내부적으로 이중 연결 리스트(doubly-linked list)를 유지합니다. 이 덕분에 요소를 순회할 때 삽입된 순서대로 접근할 수 있습니다.

### 2. 순차적 접근 성능

`LinkedHashMap`은 이중 연결 리스트를 사용하기 때문에 `for-each` 루프와 같은 순차적 접근 시 **`HashMap`보다 성능이 좋을 수 있습니다**. `HashMap`은 해시 충돌 등으로 인해 순회 시 불규칙한 메모리 접근이 발생할 수 있지만, `LinkedHashMap`은 순차적인 메모리 접근이 가능하기 때문입니다.

### 3. 해시 기반 성능

내부적으로 해시 테이블을 사용하므로, 키를 이용한 검색, 삽입, 삭제 성능은 **`HashMap`과 유사하게 평균 O(1)**의 시간 복잡도를 가집니다.

### 4. LRU 캐시 구현에 적합

`LinkedHashMap`은 `accessOrder`라는 생성자 매개변수를 통해 요소에 접근할 때마다 해당 요소를 리스트의 맨 뒤로 옮기는 기능을 지원합니다. 이 특성을 이용하면 **Least Recently Used (LRU) 캐시**를 효율적으로 구현할 수 있습니다.

**LRU 캐시 구현 예시:**

```java
// `accessOrder`를 true로 설정하여 LRU 캐시 구현에 사용
Map<String, String> lruCache = new LinkedHashMap<String, String>(16, 0.75f, true) {
    @Override
    protected boolean removeEldestEntry(Map.Entry eldest) {
        // 캐시 크기가 5를 초과하면 가장 오래된 요소를 제거
        return size() > 5;
    }
};
```

---

## 🆚 HashMap과의 비교

| 특징 | HashMap | LinkedHashMap |
| --- | --- | --- |
| **순서 보장** | ❌ (삽입 순서 보장 안 함) | ✅ (삽입 순서 보장) |
| **성능** | 삽입/삭제/검색: 평균 O(1) | 삽입/삭제/검색: 평균 O(1) |
| **메모리 사용량** | 적음 | 많음 (이중 연결 리스트 유지) |
| **주요 사용처** | 빠른 삽입/삭제가 중요한 경우 | 순서가 중요하거나 LRU 캐시 구현 시 |

### String 클래스의 matches() 메서드

### 사용법

`matches()` 메서드는 다음과 같이 사용합니다.

Java

`boolean result = yourString.matches(yourRegex);`

- `yourString`: 검사할 문자열
- `yourRegex`: 일치 여부를 확인할 정규 표현식

### 주요 특징

- **전체 일치 검사:** `matches()`는 문자열의 **전체 내용**이 정규 표현식과 일치하는지 확인합니다. 문자열의 일부만 일치하는 경우에는 `false`를 반환합니다. 만약 부분 일치를 확인하고 싶다면 `Pattern`과 `Matcher` 클래스를 사용해야 합니다.
- **정규 표현식 문법:** 정규 표현식은 복잡한 패턴을 정의하는 데 사용되는 문법입니다. 예를 들어, `.`은 모든 단일 문자를, 는 0개 이상의 반복을, `^`는 문자열의 시작을, `$`는 문자열의 끝을 의미합니다.

---

### 예시

### 1. 간단한 패턴 일치

```java
String text = "hello";

// "hello"와 정확히 일치하는지 검사
boolean match1 = text.matches("hello"); // true
System.out.println(match1);

// "world"와 일치하는지 검사
boolean match2 = text.matches("world"); // false
System.out.println(match2);
```

### 2. 정규 표현식 사용

```java
// 숫자 3개-숫자 4개-숫자 4개 형태의 전화번호
String phoneNumber = "010-1234-5678";
boolean isPhoneNumber = phoneNumber.matches("\\d{3}-\\d{4}-\\d{4}"); // true
System.out.println(isPhoneNumber);

// 유효한 이메일 형식인지 검사
String email = "example@domain.co.kr";
boolean isValidEmail = email.matches("[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}"); // true
System.out.println(isValidEmail);

// `[0-9]` 또는 `\\d`는 숫자를 의미합니다. `+`는 1회 이상 반복을 의미합니다.
// `[a-zA-Z0-9._%+-]+`는 `@` 앞의 사용자 이름 부분을 나타냅니다.
```

### 주의사항

- `matches()` 메서드의 인자로 전달되는 정규 표현식은 **문자열 리터럴**이므로, 정규 표현식에서 특수 문자를 사용하려면 **이스케이프(escape)** 처리가 필요합니다. 예를 들어, 정규 표현식의 `\`를 표현하려면 `\\`로 두 번 써야 합니다.
- `matches()`는 문자열 전체를 검사하므로, `^` (시작)와 `$` (끝) 메타 문자를 자동으로 포함합니다. 따라서 정규식에 이들을 명시적으로 추가할 필요는 없습니다. 만약 `matches("abc")`를 사용하면, 이는 내부적으로 `matches("^abc$")`와 동일하게 작동합니다.

### 번외 : github io 만들기

ruby에서 로컬 블로그 실행 명령어 : 

`gem install jekyll`
`gem install bundler`

`bundle install`

`bundle exec jekyll serve`

빌드 버전 

- ruby 3.3.6 (2024-11-05 revision 75015d4c1f) [x64-mingw-ucrt]
- jekyll 4.4.1
- Bundler version 2.7.1