# Chapter2. 값(Value)

## 2.1 배열

- 자바스크립트의 배열은 문자열, 숫자, 객체 심지어 다른 배열이나 어떤 타입의 값이라도 담을 수 있는 그릇이다.
- 구멍 난(sparse) 배열을 다룰 때는 조심하자

```jsx
var a = [];
a[0] = 1;
// 'a[1]' 슬롯을 건너뛰었다!
a[2] = [3];

a[1]; // undefined

a.length; // 3
```

- 배열 인덱스는 숫자인데, 배열 자체도 하나의 객체여서 키/프로퍼티 문자열을 추가할 수 있다. (하지만 배열 length가 증가하지는 않는다)는 점이 다소 까다롭다.

```jsx
let a = [];
a[0] = 1;
a["foobar"] = 2;

a.length; // 1
a["foobar"]; // 2;
a.foobar; // 2
```

- 키로 넣은 문자열 값이 표준 10진수 숫자로 타입이 바뀌면, 마치 문자열 키가 아닌 숫자 키를 사용한 것 같은 결과가 초래된다는 점을 주의하자
  - 일반적으로 배열에 문자열 타입의 키/프로퍼티를 두는 건 추천하지 않는다. 그렇게 해야 한다면 객체를 대용하고, 배열 원소의 인덱스는 확실히 숫자만 쓰자

```jsx
var a = [];

a["13"] = 42;
a.length; // 14
```

### 2.1.1 유사 배열(array-like object)

- 유사 배열 값 (숫자 인덱스가 가리키는 값들의 집합)을 진짜 배열로 바꾸고 싶을 때가 더러 있다.
- ES6부터 도입된 `Array.from()` 메소드를 사용하자!

---

`Array.from()`은 JavaScript에서 **유사 배열 객체(array-like object)**나 **이터러블(iterable)**을 **진짜 배열(Array)**로 변환하는 메소드입니다. ES6에서 도입되었고, 문자열, Set, Map, arguments 객체 등 다양한 구조를 배열로 바꿀 수 있다.

---

**✅ 기본 문법**

```jsx
Array.from(arrayLike[, mapFn[, thisArg]])
```

- `arrayLike`: 배열처럼 인덱스와 length를 가진 객체 또는 iterable
- `mapFn`: 각 요소에 적용할 함수 (선택)
- `thisArg`: `mapFn`에서 사용할 `this` (선택)

---

🔍 주요 사용 예시

1. **문자열 → 배열**

```jsx
Array.from("hello"); // ['h', 'e', 'l', 'l', 'o']
```

2. **Set → 배열**

```jsx
const set = new Set([1, 2, 3]);
Array.from(set); // [1, 2, 3]
```

3. **Map → 배열**

```jsx
const map = new Map([
  ["a", 1],
  ["b", 2],
]);
Array.from(map); // [['a', 1], ['b', 2]]
```

4. **arguments 객체 → 배열**

```jsx
function example() {
  const args = Array.from(arguments);
  console.log(args); // [1, 2, 3]
}
example(1, 2, 3);
```

5. **`mapFn`으로 요소 가공**

```jsx
Array.from([1, 2, 3], (x) => x * 2); // [2, 4, 6]
```

---

🧠 왜 유용할까?

- `Array.from()`은 **유사 배열을 진짜 배열로 바꾸고**, **가공까지 한 번에 처리**할 수 있어요.
- 특히 DOM 요소나 arguments 객체처럼 배열처럼 보이지만 실제 배열이 아닌 경우에 매우 유용합니다.

---

✍️ 요약

| 기능      | 설명                                             |
| --------- | ------------------------------------------------ |
| 변환 대상 | 문자열, Set, Map, arguments, 유사 배열           |
| 반환값    | 진짜 배열                                        |
| 추가 기능 | `mapFn`으로 요소 가공 가능                       |
| 대체 가능 | `Array.prototype.slice.call()`보다 간결하고 안전 |

---

## 2.2 문자열

- 자바스크립트에서 문자열은 문자의 배열이 아니다.
  - length 프로퍼티, indexOf() 메소드, concat() 메소드를 가지지만 문자열은 불변값(immutable)이고, 문자의 배열은 가변값(mutable)이다.
- 문자열 메소드는 그 내용을 바로 변경하지 않고 항상 새로운 문자열을 생성한 후 반환한다. 반면에 대부분의 배열 메소드는 그 자리에서 곧바로 원소를 수정한다.
- 문자열을 다룰 때 유용한 대부분의 배열 메소드는 사실상 문자열에 쓸 수 없지만, 문자열에 대해 불변 배열 메소드를 빌려 쓸 수는 있다.

```jsx
var a = "foo";
var b = ["f", "o", "o"];
a.join; // undefined
b.map; // undefined

var c = Array.prototype.join.call(a, "-"); // c : "f-o-o"
var d = Array.prototype.map
  .call(a, function (v) {
    return v.toUppercase() + ".";
  })
  .join(""); // d : "F.O.O."
```

- 문자열의 순서를 거꾸로 뒤집는 코드는 배열에는 reverse() 라는 가변 메서드가 준비되어 있지만, 문자열은 그렇지 않다.

```jsx
a.reverse; // undefined

b.reverse(); // ["!","o","O","f"]
b; // ["!","o","O","f"]
```

- 일단 문자열을 배열로 바꾸고 원하는 작업을 수행한 후 다시 문자열로 되돌리는 것이 또 다른 꼼수(전문 용어로는 핵Hack이라고 한다.)
  - 이 방법은 **문자 단위로 잘라서 뒤집기** 때문에, **이모지나 유니코드 조합 문자**에서는 예상과 다르게 동작할 수 있다.
  - 예: `"👨‍👩‍👧‍👦"` 같은 조합 이모지는 깨질 수 있음

```jsx
var c = a
  .split("") // 'a'를 문자열의 배열로 분할하고
  .reverse() // 문자 배열의 순서를 거꾸로 뒤집고
  .join(""); // 문자 배열을 합쳐 다시 문자열로 되돌린다.

c; // "oof"
```

- https://github.com/mathiasbynens/esrever : 복잡한 문자가 섞여 있는 경우 위의 방법은 통하지 않는다. 제대로 처리하려면 유니코드를 인식하는 정교한 라이브러리 유틸리티가 필요하다.
- 유니코드-safe 버전

```jsx
function reverseUnicode(str) {
  return Array.from(str).reverse().join("");
}

console.log(reverseUnicode("hello")); // "olleh"
console.log(reverseUnicode("👨‍👩‍👧‍👦")); // "👦‍👧‍👩‍👨" ← 올바르게 뒤집힘
console.log(reverseUnicode("안녕하세요")); // "요세하녕안"
```

- 🔍 왜 `Array.from()`이 안전한가?
  - `split('')`은 UTF-16 코드 단위로 나누기 때문에 **조합 문자나 이모지를 깨뜨릴 수 있음**
  - `Array.from()`은 **문자 단위가 아닌 유니코드 문자 단위로 분리**하기 때문에 안전하게 처리됨

## 2.3 숫자

- 자바스크립트의 숫자 타입은 number가 유일하며 ‘정수(Integer)’, ‘부동 소수점 숫자(Fractional Decimal Number’를 모두 아우른다. ‘정수’에 따옴표를 친 건, 다른 언어와 달리 자바스크립트에는 진정한 정수가 없다는 이유로 오랫동안 욕을 먹어왔기 때문
- 자바스크립트의 ‘정수’는 부동 소수점 값이 없는 값이다(예: 42.0은 ‘정수’ 42와 같다)
- 사실상 모든 스크립트 언어를 통틀어 대부분의 현대 프로그래밍 언어는 ‘IEEE 754’ 표준(부동 소수점 표준)을 따른다. 자바스크립트 number도 IEEE 754 표준을 따르며, 그중에서도 정확히는 ‘배 정도(Double Precision)’ 표준 포맷(64비트 바이너리)를 사용한다.

### **2.3.1 숫자 구문**

- 10진수 리터럴로 표시한다.
- 소수점 앞 정수가 0이면 생략 가능하다.

```jsx
var a = 0.42;
var b = 0.42;
```

- 소수점 이하가 0일 때도 생략 가능하다.

```jsx
var a = 42.0;
var b = 42;
```

- 아주 크거나 아주 작은 숫자는 지수형(Exponential Form)으로 표시하며, toExponential() 메소드의 결과값과 같다.

```jsx
var a = 5e10;
a; // 50000000000 (0이 10개)
a.toExponential(); // "5e+10"
```

- 숫자 값은 Number 객체 래퍼(Wrapper)로 박싱(Boxing)할 수 있기 때문에 Number.prototype 메소드로 접근할 수도 있다. 예를 들면 `toFixed()` 메소드는 지정한 소수점 이하 자릿수까지 숫자를 나타낸다.
  - 실제로는 숫자 값을 문자열 형태로 반환하며, 원래 값의 소수점 이하 숫자보다 더 많은 자릿수를 지정하면 그만큼 0이 우측에 붙는다.
  - `toPrecision()` 도 기능은 비슷하지만 유효 숫자 개수를 지정할 수 있다.

```jsx
var a = 42.59;

a.toFixed(0); // "43"
a.toFixed(1); // "42.6"
a.toFixed(2); // "42.59"
a.toFixed(3); // "42.590"
a.toFixed(4); // "42.5900"

a.toPrecision(1); // "4e+1"
a.toPrecision(2); // "43"
a.toPrecision(3); // "42.6"
a.toPrecision(4); // "42.59"
a.toPrecision(5); // "42.590"
a.toPrecision(6); // "42.5900"
```

### **2.3.1 작은 소수 값**

```jsx
0.1 + 0.2 === 0.3; // false : 0.30000000000000004
```

- 어떻게 처리할까? ⇒ 미세한 ‘반올림 오차’를 허용 공차(Tolerance)로 처리하는 방법이 있다. 이렇게 미세한 오차를 ‘머신 입실론’이라고 하는데, 자바스크립트 숫자의 머신 입실론은 2^(-52) = 2.220440…e-16이다.
- ES6부터는 이 값이 Number.EPSILON으로 미리 정의되어 있으므로 필요시 사용하면 되고, ES6 이전 브라우저는 다음과 같이 폴리필을 대신 사용한다.

```jsx
if (!Number.EPSILON) {
  Number.EPSILON = Math.pow(2, -52);
}
```

- 두 숫자의 동등 비교

```jsx
function numbersCloseEnoughToEqual(n1, n2) {
  return Math.abs(n1 - n2) < Number.EPSILON;
}

numbersCloseEnoughToEqual(a, b); // true
```

- 부동 소수점 숫자의 최댓값은 대략 1.798e+309이고 Number.MAX_VALUE로 정의하며, 최솟값은 5e-324로 음수는 아니지만 거의 0에 가까운 숫자고 Number.MIN_VALUE로 정의한다.

### **2.3.3 안전한 정수 범위**

- 정수는 Number.MAX_VALUE보다 훨씬 작은 수준에서 안전(safe) 값의 범위가 정해져 있다.
- 안전하게 표현할 수 있는(즉, 표현한 값과 실제 값이 정확하게 일치한다고 장담할 수 있는) 정수는 최대 2^53 -1 이다. 약 9천조가 넘는다.
- 이 값은 ES6에서 Number.MAX_SAFE_INTEGER로 정의한다. 최솟값은 Number.MIN_SAFE_INTEGER로 정의하며 -900… 이다.

**정수인지 확인**

- ES6부터는 `Number.isInteger()`로 어떤 값의 정수 여부를 확인한다.

```jsx
Number.isInteger(42); // true
Number.isInteger(42.0); // true
Number.isInteger(42.3); // false
```

- 안전한 정수 여부는 ES6부터 Number.isSafeInteger() 로 체크한다.

### **2.3.5 32비트 (부호 있는) 정수**

- 32비트 숫자에만 가능한 연산이 있으므로 실제 범위는 훨씬 줄어든다.
- 정수의 안전 범위는 Math.pow(-2,31) (약 -21억)에서 Math.pow(2,31)-1 (+약21억) 까지다.

## 2.4 특수 값

### 2.4.1 값 아닌 값

- Undefined 타입의 값은 `undefined` 밖에 없다.
- null 타입의 값도 `null` 밖에 없다. 그래서 이 둘은 타입과 값이 항상 같다.
- null은 식별자가 아닌 특별한 키워드이므로 `null`이라는 변수에 뭔가 할당할 수는 없다.
- (불행히도) `undefined`는 식별자로 쓸 수 있다.

### 2.4.2 Undefined

- 느슨한 모드에서 전역 스코프에서 undefined란 식별자에 값을 할당할 수 있다.(절대 하지말자!)
- 모드에 상관없이 undefined란 이름을 가진 지역 변수는 생성할 수 있다. (이것도 절대하지말자)

**_void 연산자_**

- undefined는 내장 식별자로, 값은 undefined지만, 이 값은 void 연산자로도 얻을 수 있다.
- 표현식 void \_\_는 어떤 값이든 ‘무효로 만들어, 항상 결괏값을 undefined로 만든다.
- 기존 값은 건드리지 않고 연산 후 값은 복구할 수 없다.
- 관례에 따라 void만으로 undefined 값을 나타내려면 `void 0`이라고 쓴다.
- `void` 연산자는 어떤 표현식의 결괏값이 없다는 걸 확실히 밝혀야 할 때 긴요하다. 예를 들어

```jsx
function doSomething() {
  // 참고: 'APP.ready'는 이 애플리케이션에서 제공한 값이다.
  if (!APP.ready) {
    // 나중에 다시 해보자!
    return void setTimeout(doSomething, 100);
  }
  var result;
  // 별도 처리 수행
  return result;
}

if (doSomething()) {
  // 다음 작업 바로 실행
}
```

---

🔍 핵심 코드 요약

```jsx
if (!APP.ready) {
  return void setTimeout(doSomething, 100);
}
```

이 부분이 핵심입니다.

**✅ `setTimeout()`은 어떤 값을 반환할까?**

- `setTimeout()`은 **타이머 ID**를 반환합니다. 예: `1`, `2`, `3` 같은 숫자
- 따라서 `return setTimeout(...)`만 하면 `doSomething()`은 **숫자를 반환**하게 됩니다

**❗ 문제 상황**

```jsx
if (doSomething()) {
  // 다음 작업 실행
}
```

- `doSomething()`이 숫자(예: 1)를 반환하면 → 조건문에서 **truthy**로 평가됨
- 즉, `APP.ready`가 **false**인데도 `if` 블록이 실행될 수 있음 → **논리 오류 발생**

**✅ 해결책: `void`로 반환값을 `undefined`로 고정**

```jsx
return void setTimeout(doSomething, 100);
```

- `void`는 어떤 표현식이든 **결과를 무시하고** `undefined`**를 반환**하게 만듦
- 따라서 `doSomething()`은 항상 `undefined`를 반환하고, `if (doSomething())`는 **false**가 되어 조건문이 실행되지 않음

**🧠 요약**

| 목적                         | 설명                                                        |
| ---------------------------- | ----------------------------------------------------------- |
| `setTimeout()`의 반환값 제거 | `void`를 써서 숫자 반환을 `undefined`로 무효화              |
| 조건문 오작동 방지           | `if (doSomething())`가 잘못 실행되는 걸 막음                |
| 코드 의도 명확화             | "이 호출은 부수 효과만 있고, 반환값은 무시해라"는 의도 표현 |

**✍️ 결론**

`void`는 이처럼 **"이 표현식은 실행만 하고, 결과는 무시해라"**는 의도를 명확히 할 때 매우 유용해요. 특히 **조건문, 이벤트 핸들러, 콜백**에서 부작용만 원할 때 자주 쓰입니다.

### 2.4.3 특수 숫자

**NaN**

- 글자 그대로 숫자 아님(Not A Number)이지만, 숫자 아님 보다는 ‘유효하지 않은 숫자’, ‘실패한 숫자’, 또는 ‘몹쓸 숫자’라고 하는게 차라리 더 정확함.

```jsx
var a = 2 / "foo"; // NaN
typeof a === "number"; // true
```

- 즉, 숫자 아님의 typeof는 숫자다! 란 뜻이다.
- 동등 연산자와 일치 연산자로 비교할 수 없다!

```jsx
var a = 2 / "foo";
a == NaN; // false;
a === NaN; // false;
```

- 내장 전역 유틸리티 isNan() 함수가 NaN 여부를 말해주지만, 이 함수는 NaN의 의미를 너무 글자 그대로만 해석해서 실제로 ‘인자 값이 숫자인지 여부를 평가’하는 기능이 전부

```jsx
var a = 2 / "foo";
var b = "foo";

window.isNaN(a); //true
window.isNaN(b); // true --??!
```

- ES6부터는 `Number.isNan()`이 등장한다.
- ES6 이전 브라우저에서는 다음 폴리필을 쓰면 안전하게 NaN 여부를 체크할 수 있다.

```jsx
if (!Number.isNaN) {
	Number.isNaN = function(n) {
		return {
			typeof n === "number" && window.isNaN( n )
		};
	};
}

var a = 2 / "foo";
var b = "foo";

window.isNaN( a ); // true
window.isNaN( b ); // false!
```

**_무한대_**

- 자바스크립트에서는 0으로 나누기 연산이 잘 정리되어 있어서 에러 없이 Infinity(Number.POSITIVE_INFINITY)라는 결괏값이 나온다.

```jsx
var a = 1 / 0; // Infinity
var b = -1 / 0; // -Infinity
```

**_0(영)_**

```jsx
var a = 0 / -3; // -0
var b = 0 * -3; // -0
```

+0 / -0 개념 : 어떤 변수값이 0에 도달하여 부호가 바뀌는 순간, 그 직전까지의 이 변수의 이동 방향은 무엇인지 알 수가 없으므로 부호가 다른 두 0은 유효하다. ⇒ 잠재적인 정보 소실을 방지하기 위해 0의 부호를 보존함.

### 2.4.4 특이한 동등 비교

- ES6부터는 잡다한 예외를 걱정하지 않아도 두 값이 절대적으로 동등한지를 확인하는 새로운 유틸리티를 지원한다. 바로 `Object.is()` 다

```jsx
var a = 2 / "foo";
var b = -3 * 0;

Object.is(a, NaN); // true
Object.is(b, -0); // true
Object.is(b, 0); // false
```

---

## 2.5 값 vs 레퍼런스

> 다른 언어에서 값은 사용하는 구문에 따라 값-복사 (Value-Copy) 또는 레퍼런스-복사 (Reference-Copy)의 형태로 할당/전환된다.
> 레퍼런스는 포인터의 특수한 형태로 다른 변수의 포인터를 가진다. 래퍼런스 인자를 선언하지 않으면 전달한 값은 아무리 복잡한 객체일지라도 언제나 복사된다.

🔍 “레퍼런스는 포인터의 특수한 형태로 다른 변수의 포인터를 가진다.”

- **레퍼런스(reference)**는 **포인터처럼 동작하지만 문법적으로 더 간단하고 안전한 방식**
- 포인터는 변수의 주소를 직접 다루지만, 레퍼런스는 **그냥 다른 이름처럼 동작한다.**
- 예를 들어:

```cpp
int a = 10;
int& ref = a; // ref는 a의 레퍼런스
ref = 20;     // a도 20으로 바뀜
```

- 여기서 `ref`는 `a`의 주소를 내부적으로 가지고 있지만, 포인터처럼 `ref` 이런 식으로 쓰지 않아요.

---

🔍 “래퍼런스 인자를 선언하지 않으면 전달한 값은 아무리 복잡한 객체일지라도 언제나 복사된다.”

- 함수에 인자를 넘길 때, **레퍼런스로 넘기지 않으면 복사본이 만들어진다.**
- 예를 들어:

```cpp
void modify(MyObject obj) { // 복사본을 받음
  obj.value = 100;
}
```

- 위 함수는 `obj`의 복사본을 받기 때문에 원래 객체는 바뀌지 않는다.
- 반면에:

```cpp
void modify(MyObject& obj) { // 원본을 참조함
  obj.value = 100;
}
```

- 이렇게 하면 원래 객체의 값을 직접 바꾸게 된다.

---

**💡 핵심 요약**

| 개념      | 설명                                        |
| --------- | ------------------------------------------- |
| 포인터    | 변수의 주소를 직접 다룸 (`int* p = &a`)     |
| 레퍼런스  | 변수의 또 다른 이름처럼 동작 (`int& r = a`) |
| 값 전달   | 복사본을 넘김 → 원본은 안 바뀜              |
| 참조 전달 | 원본을 직접 넘김 → 원본이 바뀜              |

---

- 자바스크립트는 포인터라는 개념 자체가 없고 참조하는 방법도 조금 다름.
- 어떤 변수가 다른 변수를 참조할 수 없다.
  - 아래의 예시에서 `var b = a` 는 b 가 a를 참조하는 것이 아니라, a가 가진 값의 타입에 따라 값을 복사하거나, 레퍼런스를 복사하거나 둘 중 하나다!
- 자바스크립트에서 레퍼런스는 (공유된) 값을 가리키므로 서로 다른 10개의 레퍼런스가 있다면 이들은 저마다 항상 공유된 단일 값(서로에 대한 레퍼런스/포인터 따위는 없다)을 개별적으로 참조한다.
- 더구나 자바스크립트에는 값 또는 레퍼런스의 할당 및 전달을 제어하는 구문 암시(Syntatic Hint)가 전혀 없다. 대신, 값의 타입만으로 값-복사, 레퍼런스-복사 둘 중 한쪽이 결정된다.
- 예를 들어,

```jsx
var a = 2;
var b = a; // 'b'는 언제나 'a'에서 값을 복사한다.
b++;
a; // 2
b; // 3

var c = [1, 2, 3];
var d = c; // 'd'는 공유된 '[1,2,3]' 값의 레퍼런스다.
d.push(4);
c; // [1,2,3,4]
d; // [1,2,3,4]
```

- null, undefined, string, number, boolean 그리고 ES6의 symbol 같은 단순 값(스칼라 원시 값: Scalar Primitives)은 언제나 값-복사 방식으로 할당/전달된다.
- 객체(배열과 박상된 객체 래퍼 전체)나 함수 등 함성 값(Composed Values)은 할당/전달 시 반드시 레퍼런스 사본을 생성한다.
- 위의 예제 코드에서 `2` 는 스칼라 원시 값이므로 a엔 이 값의 초기 사본이 들어아고, b에는 또 다른 사본이 자리를 잡는다. 따라서 b를 바꿈으로써 a까지 동시에 값을 변경할 방법은 없다.
- 하지만, c와 d는 합성 값이자 동일한 공유 값 `[1,2,3]` 에 대한 개별 레퍼런스다.
  - 기억해야 할 점은 c와 d가 `[1,2,3]` 을 ‘소유’하는 것이 아니라 단지 이 값을 동등하게 참조만 한다는 사실이다.
  - 따라서 레퍼런스로 실제 공유한 배열 값이 변경되면, 이 공유 값 한 군데에만 영향을 미치므로 두 레퍼런스는 갱신된 값 `[1,2,3,4]` 를 동시에 바라보게 된다.
- 레퍼런스는 변수가 아닌 값 자체를 가리키므로 A 레퍼런스로 B 레퍼런스가 가리키는 대상을 변경할 수는 없다. 예를 들어,

```jsx
var a = [1, 2, 3];
var b = a;
a; // [1,2,3]
b; // [1,2,3]
b = [4, 5, 6];
a; // [1,2,3]
b; // [4,5,6]
```

- 위의 예시 처럼 b를 새로 할당해도 a가 참조하는 [1,2,3]은 영향을 받지 않는다. 그렇게 되려면 b가 배열을 가리키는 레퍼런스가 아닌 포인터가 되어야 하는데, 다시 말하지만 자바스크립트에 포인터란 없다.
- 함수 인자 역시 헷갈리지 말자!

```jsx
function foo(x) {
  x.push(4);
  x; // [1,2,3,4]

  // 그 후
  x = [4, 5, 6];
  x.push(7);
  x; // [4,5,6,7]
}

var a = [1, 2, 3];

foo(a);

a; // [4,5,6,7]이 아닌 [1,2,3,4]
```

- a를 인자로 넘기면 a의 레퍼런스 사본이 x에 할당된다. x와 a는 모두 동일한 `[1,2,3]` 값을 가리키는 별도의 레퍼런스다. 이제 함수 내부에서 이 레퍼런스를 이용하여 값 자체를 변경한다. (`push(4)`)
- 하지만, 그 후 x 에 새 값을 할당해도 당연히 초기 레퍼런스 a가 참조하고 있던 값에는 아무런 영향이 없다.

```jsx
function foo(x) {
  x.push(4);
  x; // [1,2,3,4]

  // 그 후
  x.length = 0; // 기존 배열을 즉시 비운다.
  x.push(4, 5, 6, 7);
  x; // [4,5,6,7]
}

var a = [1, 2, 3];
foo(a);
a; // [1,2,3,4]가 아닌 [4,5,6,7]
```

- 값-복사냐 레퍼런스-복사냐를 개발자 마음대로 결정할 수 없음을 기억하자. 전적으로 값의 타입을 보고 엔진의 재량으로 결정된다.
- (배열 같은) 합성 값을 값-복사에 의해 효과적으로 전달하려면 손수 값의 사본을 만들어 전달한 레퍼런스가 원본을 가리키지 않게 하면 된다. 예를 들어,

```jsx
foo(a.slice());
```

- 인자 없이 `slice()` 를 호출하면 전혀 새로운 배열의 (얕은 복사에 의한) 사본을 만든다. 이렇게 복사한 사본만을 가리키는 레퍼런스를 전달하니 `foo()`는 더이상 a 의 내용을 건드릴 수 없다.
- 반대로 스칼라 원시 값을 레퍼런스처럼 바뀐 값이 바로바로 반영되도록 넘기려면 원시 값을 다른 합성 값(객체, 배열 등)으로 감싸야 한다.

```jsx
function foo(wrapper) {
  wrapper.a = 42;
}

var obj = {
  a: 2,
};
foo(obj);
obj.a; // 42
```

- obj는 스칼라 원시 프로퍼티 a를 감싼 래퍼로 foo() 함수에 obj 레퍼런스 사본이 전달되고 래퍼 인자의 값을 바꾼다.
- 이제 래퍼 레퍼런스로 공유된 객체에 접근하여 프로퍼티를 수정할 수 있다. 함수가 종료되면 obj.a는 수정된 값, 42다.
- 같은 원리로 2와 같은 스칼라 원시 값을 레퍼런스 형태로 넘기려면 Number 객체 래퍼로 원시값을 박싱하면 된다.
- Number 객체의 레퍼런스 사본이 함수에 전달되는 것은 맞지만 아쉽게도 공유된 객체를 가리키는 레퍼런스가 있다고 자동으로 공유된 원시 값을 변경할 권한이 주어지는 것은 아니다.

```jsx
function foo(x) {
  x = x + 1;
  x; // 3
}

var a = 2;
var b = new Number(a); // 'Object(a)'도 같은 표현

foo(b);
console.log(b); // 3이 아닌 2
```

- 문제는 내부의 스칼라 원시 값이 불변임. (문자열, 불리언도 마찬가지다)
- 표현식 x = x +1에서 x 가 사용될 때 내부에 간직된 스칼라 원시 값 2는 Number 객체에서 자동 언박싱(추출) 되므로 x = x+1의 x는 공유된 레퍼런스에 Number 객체에서 아주 교묘하게 뒤바뀌고 덧셈 결과인 스칼라 원시 값 3을 갖게 된다.
- 바깥의 b는 원시 값 2를 씌운, 변경되지 않은/불면의 원본 Number 객체를 참조한다.
- Number 객체에 프로퍼티를 추가하고, 간접적이나마 추가된 프로퍼티를 통하여 정보 교환을 할 수는 있으나, 일반적이지 않고 좋은 습관은 아님.

## 2.6 정리하기

- 자바스크립트 배열은 모든 타입의 값들을 숫자로 인덱싱한 집합
- 문자열은 일종의 ‘유사배열’이지만, 나름 특성이 있기 때문에 배열로 다루고자할 때는 조심하자
- 자바스크립트 숫자는 ‘정수’와 ‘부동 소수점 숫자’ 모두 포함한다.
- 원시 타입에는 몇몇 특수 값이 있다.
  - null 타입은 null 이란 값 하나뿐이고, 마찬가지로 undefined 타입도 값은 undefined 뿐이다.
  - undefined는 할당된 값이 없다면 모든 변수/프로퍼티의 디폴트 값이다.
  - void 연산자는 어떤 값이라도 undefined로 만들어 버린다.
- 숫자에는 NaN, +Infinity, -Infinity, -0 같은 특수값이 있다.
- 단순 스칼라 원시 값(문자열, 숫자 등)은 값-복사에 의해, 합성 값(객체 등)은 레퍼런스-복사에 의해 값이 할당/전달된다.
- 자바스크립트에서의 레퍼런스는 다른 언어의 레퍼런스/포인터와는 전혀 다른 개념으로, 또 다른 변수/레퍼런스가 아닌 오직 자신의 값을 가리킨다.
