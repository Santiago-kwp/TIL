# Chapter1. 타입(Type)

> ‘타입’이란 자바스크립트 엔진, 개발자 모두에게 어떤 값을 다른 값과 분별할 수 있는, 고유한 내부 특성의 집합이다. 다시 말해, 기계(엔진)와 사람(개발자)이 42(숫자)란 값을 “42” (문자열)란 값과 다르게 취급한다면, 두 값은 타입(즉, 숫자와 문자열)이 서로 다르다. 42는 수학 연산 같이 계산을 하려는 의도지만 “42”는 필경 페이지에 출력할 문자열 비슷한 것으로 쓸 의도로 만든 값이다.

## 1.1 타입, 그 실체를 이해하자

> 타입별로 내재된 특성을 제대로 알고 있어야 값을 다른 타입으로 변환하는 방법을 정확히 이해할 수 있다. 어떤 형태로든 거의 모든 자바스크립트 프로그램에서 **_강제변환(coercion)_**이 일어나므로 타입을 확실하게 인지하고 사용하는 것이 중요하다.

## 1.2 내장 타입

- 자바스크립트에는 다음 7가지 내장 타입이 있다.
  - null
  - undefined
  - boolean
  - number
  - string
  - object
  - symbol (ES6부터 추가)
- 각 타입은 `typeof` 연산자로 알 수 있다. 그럼 `typeof` 반환 값은 항상 7가지 내장 타입 중 하나일까? 놀랍게도 목록의 7가지 내장 타입과 1:1로 정확히 매치되지는 않는다?!

```jsx
typeof undefined === "undefined"; // true
typeof true === "boolean"; // true
typeof 42 === "number"; // true
typeof "42" === "string"; // true
typeof { life: 42 } === "object"; // true
typeof Symbol() === "symbol"; // true
```

- `null` 에 대한 typeof 연산 결과는 꼭 버그처럼 보인다.

```jsx
typeof null === "object"; // true
```

- 그래서 타입으로 null 값을 정확히 확인하려면 조건이 하나 더 필요하다.

```jsx
var a = null;
!a && typeof a === "object"; // true
```

- null은 falsy한 (false나 다름없는) 유일한 원시 값이지만, 타입은 ‘object’인 특별한 존재
- typeof가 반환하는 문자열은 하나 더 있다.

```jsx
typeof function a() {
  /* ... */
} === "function"; // true
```

- function은 최상위 레벨의 내장 타입처럼 보이지만, 명세를 읽어보면 실제로는 object의 ‘하위 타입’이다.
  - 구체적으로 설명하면 함수는 ‘호출 가능한 객체 (Callable Object)’
  - 사실 함수는 객체라서 유용하다. 무엇보다 함수에 프로퍼티를 둘 수 있다.
  ```jsx
  function a(b, c) {
    /* ... */
  }
  ```
- 배열은 그냥 객체다

```jsx
typeof [1, 2, 3] === "object"; // true
```

## 1.3 값은 타입을 가진다.

- 값에는 타입이 있지만, 변수엔 따로 타입이 없다. 변수는 언제라도, 어떤 형태의 값이라도 가질 수 있다.
- 자바스크립트는 ‘타입 강제(Type Enforcement)’를 하지 않는다. 변숫값이 처음에 할당된 값과 동일한 타입일 필요는 없다. 문자열을 넣었다가 나중에 숫자를 넣어도 상관없다.
- 변수에 typeof 연산자를 대어보는건 “이 변수의 타입은 무엇이니?” 라는 질문과 같지만, 실은 타입이란 개념은 변수에 없으므로 정확히는 **_“이 변수에 들어있는 값의 타입은 무엇이니?”_** 라고 묻는 것이다.

```jsx
var a = 42;
typeof a; // "number"
a = true;
typeof a; // "boolean"
```

- `typeof` 연산자의 반환 값은 언제나 문자열이다.
- 값이 없는 변수의 값은 `undefined` 이며 typeof 결과는 “undefined” 다.

```jsx
var a;
typeof a; // "undefined"
var b = 42;
var c;

// 그리고 나서,
b = c;
typeof b; // "undefined"
typeof c; // "undefined"
```

- “undefined” (값이 없는)와 “undefined” (선언되지 않은)를 동의어처럼 생각하기 쉬우나, 자바스크립트에서 둘은 완전히 다른 개념이다.
  - 전자는 접근 가능한 스코프에 변수가 선언되었으나, 현재 아무런 값도 할당되지 않은 상태
  - 후자는 접근 가능한 스코프에 변수 자체가 선언조차 되지 않은 상태를 의미한다.

```jsx
var a;
a; //undefined
b; // Uncaught ReferenceError: b is not defined
// at <anonymous>:1:1

typeof a; // "undefined"
typeof b; // "undefined"
```

- 선언조차 하지 않은 변수인데 `typeof` 를 해도 브라우저는 오류 처리를 하지 않는다. 이것이 `typeof` 만의 독특한 안전 가드다.
- 브라우저에서 자바스크립트 코드를 처리할 때, 특히 여러 스크립트 파일의 변수들이 전역 네임스페이스를 공유할 때, typeof의 안전 가드는 의외로 쓸모가 있다.
  - 간단한 예로, 프로그램의 ‘디버그 모드’를 DEBUG라는 전역 변수 (플래그)로 조정한다고 치자. 콘솔 창에 메시지 로깅 등 디버깅 작업을 수행하기 전, 이 변수의 선언 여부를 체크해야 할 것이다. 최상위 전역 스코프에 `var DEBUG = true` 라고 ‘debug.js’ 파일에만 선언하고, 개발/테스트 단계(운영 단계는 제외)에서 이 파일을 브라우저가 로딩하기만 하면 될 것이다.
  - 그러나 나머지 애플리케이션 코드에서 ReferrenceError 가 나지 않게 하려면 조심해서 DEBUG 전역 변수를 체크해야 한다. 바로 이럴 때 우리의 친구, typeof 안전 가드가 제 몫을 해낸다.
  ```jsx
  // 이렇게 하면 에러가 난다!
  if (DEBUG) {
    console.log(" 디버깅을 시작합니다");
  }

  // 이렇게 해야 안전하게 존재 여부를 체크할 수 있다.
  if (typeof DEBUG !== "undefined") {
    console.log("디버깅을 시작합니다");
  }
  ```
- (DEBUG 같은) 임의로 정의한 변수를 쓰지 않더라도 이런 식으로 체크하는 것이 편리하며, 내장 API 기능을 체크할 때에도 에러가 나지 않게 도와준다.
  ```jsx
  if (typeof atob === "undefined") {
    atob = function () {
      /* ... */
    };
  }
  ```
- `typeof` 안전 가드 없이 전역 변수를 체크하는 다른 방법은 전역 변수가 모두 전역 객체(브라우저는 window)의 프로퍼티라는 점을 이용하는 것이다. 그래서 다음과 같이 (꽤 안전하게) 체크할 수 있다.
  - 선언되지 않은 변수 때와는 달리 어떤 객체 (전역 window 객체도 포함해서)의 프로퍼티를 접근할 때 그 프로퍼티가 존재하지 않아도 ReferenceError가 나지 않는다.
  ```jsx
  if (window.DEBUG) {
    // ...
  }

  if (!window.atob) {
    // ...
  }
  ```
- 하지만 window 객체를 통한 전역 변수 참조는 가급적 삼가는 것이 좋다. 전역 변수를 꼭 window 객체로만 호출하지 않는 다중 자바스크립트 환경(브라우저뿐만 아니라 서버에서 실행되는 노드js 가 일례다)이라면 더욱 그렇다.

- 엄밀히 말해서 `typeof` 안전 가드는 (비록 일반적인 경우는 아니지만) 전역 변수를 사용하지 않을 때에도 유용한데, 일부 개발자들은 이런 설계 방식이 그다지 바람직하지 않다고 말한다. 이를테면 다른 개발자가 여러분이 작성한 유틸리티 함수를 자신의 모듈/프로그램에 복사 붙여넣기를 하여 사용하는데, 가져다 쓰는 프로그램에 유틸리티의 특정 변숫값이 정의되어 있는지 체크해야 하는 상황을 가정해보자

```jsx
function doSomethingCool() {
  var helper =
    typeof FeatureXYZ !== "undefined"
      ? FeatureXYZ
      : function () {
          /* ... 기본 XYZ 기능 ... */
        };

  var val = helper();
  // ...
}
```

- doSomethingCool 함수는 FeatureXYZ 변수가 있으면 그대로 사용하고 없으면 함수 바디를 정의한다. 이렇게 해야 다른 사람이 복사 붙여넣기를 해도 안전하게 FeatureXYZ가 존재하는지를 체크할 수 있다.
- 의존성 주입(Dependency Injection) 설계 패턴을 선호하는 개발자들도 있다. FeatureXYZ가 doSomethingCool()의 바깥이나 언저리에 정의되었는지 암시적으로 조사하는 대신, 다음 코드처럼 명시적으로 의존 관계를 전달하는 것이다.

```jsx
function doSomethingCool(FeatureXYZ) {
  var helper =
    FeatureXYZ ||
    function () {
      /*... 기본 XYZ 기능 ...*/
    };

  var val = helper();
  // ...
}
```

바로 이 내용이 앞서 설명한 **전역 변수 의존의 문제점을 해결하는 현대적인 방법**이자, **의존성 주입(Dependency Injection, DI)** 패턴의 핵심을 보여줍니다.

앞선 코드(`typeof` 안전 가드 사용)가 **암시적**으로 외부 환경을 조사했다면, 이 코드는 **명시적**으로 필요한 것을 함수 안으로 **"주입(Injection)"**하는 방식입니다.

---

**_의존성 주입(DI) 코드의 의미_**

제시된 코드는 `doSomethingCool` 함수가 실행되기 위해 필요한 `FeatureXYZ`라는 **의존성**을 **함수의 매개변수**를 통해 외부로부터 직접 받아들이도록 설계되었습니다.

```jsx
function doSomethingCool(FeatureXYZ) {
  // 👈 의존성을 매개변수로 명시적 전달
  var helper =
    FeatureXYZ || // 👈 전달받은 값이 있으면 사용
    function () {
      /*... 기본 XYZ 기능 ...*/
    }; // 👈 없으면 기본 기능 사용

  var val = helper();
  // ...
}
```

**1. 명시적인 의존 관계**

- **`doSomethingCool(FeatureXYZ)`:** 함수가 `FeatureXYZ`라는 외부 기능에 의존한다는 사실을 코드를 읽는 누구에게나 명확하게 알려줍니다.
- **장점:** 함수가 외부의 전역 변수에 기댈 필요가 없어집니다. 함수를 복사하여 어떤 모듈에 붙여 넣든, 그 함수는 필요한 기능만 매개변수로 전달받으면 문제없이 동작합니다.

**2. 유연한 대체 (Fallbacks)**

- **`var helper = FeatureXYZ || ...`:** 이 부분은 앞선 예시의 `typeof` 안전 가드와 비슷한 **대체(Fallback)** 기능을 수행합니다.
  - **외부에서 `FeatureXYZ`를 전달했을 경우:** `helper`는 전달받은 그 값을 사용합니다.
  - **외부에서 `FeatureXYZ`를 전달하지 않았거나(예: `undefined` 또는 `null`을 전달), 값이 `false`로 평가될 경우:** `helper`는 뒤에 정의된 익명 함수(기본 기능)를 사용합니다.

**3. DI 패턴의 장점 (선호되는 이유)**

의존성 주입 패턴은 다음과 같은 이유로 현대 개발에서 선호됩니다.

| 장점              | 설명                                                                                                                                               |
| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| **명확성**        | 함수가 무엇에 의존하는지 매개변수를 통해 **명시적**으로 알 수 있어 코드 이해도가 높습니다.                                                         |
| **테스트 용이성** | 함수를 테스트할 때, 실제 `FeatureXYZ` 기능 대신 **가짜 객체(Mock/Stub)**를 매개변수로 쉽게 주입하여 특정 시나리오를 격리하여 테스트할 수 있습니다. |
| **모듈 독립성**   | 함수가 전역 환경에 의존하지 않고 독립적으로 작동하기 때문에, 모듈 간의 결합도가 낮아지고 재사용성이 높아집니다.                                    |

## 정리하기

- 자바스크립트에는 7가지 내장 타입 (null, undefined, boolean, number, string, object, symbol) 이 있으며, `typeof` 연산자로 타입명을 알아낸다.
- 변수는 타입이 없지만, 값은 타입이 있고, 타입은 값의 내재된 특성을 정의한다.
- “undefined” 와 “undeclared” 가 대충 같다고 보는 개발자들이 많은데, 자바스크립트 엔진은 둘을 전혀 다르게 취급한다.
  - undefined는 선언된 변수에 할당할 수 있는 값이지만, undeclared는 변수 자체가 선언된 적이 없음을 나타낸다.
- 불행히도 자바스크립트는 이 두 용어를 대충 섞어버려, 에러 메시지(”ReferenceError: a is not defined”)뿐만 아니라 typeof 반환 값도 모두 “undefined”로 뭉뚱 그린다.
- 그래도 (에러를 내지 않는) typeof 안전 가드 덕분에 선언되지 않은 변수에 사용하면 제법 쓸 만하다.
