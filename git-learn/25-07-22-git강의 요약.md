## 강의 요약

### 깃(Git)의 개념

- 깃 : 버전 관리 소프트웨어로, 여기서 버전은 곧 소스코드를 의미함.
    - 역할 : 변경 내용 확인
    - 이전의 작업했던 버전으로 이동
    - 협업 가능
- 깃허브 : 깃으로 관리하는 다양한 파일들을 원격으로 저장, 관리하는 저장소
    - **백업**의 역할과 동시에 **배포**의 역할도 겸하고 있다.
    - 개발자의 SNS로 나 자신을 어필할 수 있는 공간
- 깃은 저장소 내 모든 데이터를 객체(Object) 형태로 저장한다.
    - 블롭(Blob) : 파일의 내용을 저장하는 객체 (이름 없이 내용 자체만 저장)
    - 트리(Tree) : 폴더(디렉토리) 정보를 저장하는 객체 (Blob 과 다른 Tree들을 연결하는 역할, 디렉토리 구조 표현)
    - 커밋(Commit) : 특정 시점의 변경사항 (스냅샷)과 해당 트리를 참조하고, 메타 데이터(작성자, 메시지 등)를 저장하는 객체
    - 태그(Tag) : 커밋에 별명을 붙이거나, 버전을 식별하는 데 사용됨. 주로 릴리즈 시 활용
    - 모든 객체는 SHA-1 해시를 통해 식별됨. 즉, 내용이 같으면 동일한 해시 값을 갖고, 객체도 재사용됨.
    - 커밋은 항상 하나의 Tree 객체를 참조하고, 부모 커밋 정보를 통해 히스토리를 이어감.

📁 `.git` **폴더 주요 구조와 역할**

| 디렉토리/파일 | 설명 |
| --- | --- |
| **objects/** | Git의 모든 데이터 객체(blob, tree, commit 등)를 저장하는 폴더. SHA-1 해시값 기준으로 하위 디렉토리로 분산되어 저장돼요. |
| **refs/** | 브랜치와 태그가 가리키는 커밋 정보를 담고 있어요. 예: `refs/heads/main`, `refs/tags/v1.0` |
| **HEAD** | 현재 체크아웃된 브랜치를 참조하는 파일. 예: `ref: refs/heads/main` |
| **index** | Staging area의 상태를 저장하는 파일. 커밋하기 전의 snapshot이라고 볼 수 있어요. |
| **config** | Git 저장소에 대한 설정값들 (사용자 정보, 리모트 정보 등)이 저장돼요. |
| **logs/** | 브랜치 및 HEAD 등의 변경 이력을 로그로 기록해요. 로컬 변경 히스토리를 추적할 수 있어요. |

🔍 **objects 디렉토리 속 구조**

- `objects` 폴더 안에는 **SHA-1 해시의 앞 두 자리**로 이름 지은 하위 디렉토리가 생기고, 그 안에 **나머지 해시 값**으로 된 파일이 저장돼요.
    - 예를 들어, 해시가 `4a1b2c...`이라면 `objects/4a/1b2c...` 파일 형태로 저장됨.
- 압축된 형태(zlib)로 저장되므로 파일을 직접 열어보면 알아보기 어려워요.
- Git은 같은 내용이면 같은 해시 객체를 만들어 재사용하기 때문에, 저장 공간을 아주 효율적으로 사용해요!

🎯 커밋 시 연결 구조

- **commit** → **tree** → **blob**
- 커밋 객체는 트리 객체를 참조하고, 트리는 그 디렉토리의 파일을 blob으로 연결하죠

### 깃이 관리하는 세 개의 공간

- Working directory : 작업 공간으로 내가 코드를 짜고 개발을 해서 새로운 변경 내역을 만드는 공간
- Stage(스테이지) : 변경 내용이 있는 파일들을 하나로 묶어 주는 역할. 임시로 올려두는 곳 (다음 버전이 될 후보가 올라가는 공간)
- Repository(저장소) : 커밋한 파일이 저장됨.(버전이 만들어지고 관리되는 공간)

### 깃 관련 추가 지식

- commit : 물리적으로는 커밋, 논리적으로는 version이라고 많이 사용한다.
- 커밋해시(CommitHash) : 각각의 버전에 지칭된(인덱싱된) 고유한 정보(ID)
- 태그(#) : 각각의 커밋 중에서 마일스톤 같은 역할로 포스트잇이라고 할 수 있음.
- 깃으로 관리하는 파일은 맨 밑에 공백이 있는 것이 좋음. 아니면 warning이 뜰 수 있음.
- `main` : 처음 로컬 저장소에 깃 생성 시 default 깃 브랜치의 이름.
- `origin/main` : 깃허브 원격 저장소에 깃 생성 시 default 깃 브랜치 이름

### 버전 되돌리기

- dump 를 떠서 웬만하면 백업을 해버리자!
- `revert` : 현재 이전의 버전으로 새 커밋을 생성하는 것. 즉, 버전을 되돌린 새로운 버전을 만들기
- `reset` : 현재 이후의 버전을 없애버림.(버전을 완전히 되돌리기) 범위는 아래 세 가지가 있음
    - soft : `commit` 이전의 상태, 즉 맨 마지막 스테이지 공간에 변경 내역 파일이 올라간 상황
    - mixed : `add` 이전의 상태, 변경 내역이 작업 공간에 있는 상황
    - hard : 작업 공간까지 내역을 없애 버림
- `stash` : 임시 저장으로 작업 공간에 있는 변경 내역이 있는 파일들의 상태(스냅샷이겠지?)를 임시로 보관 및 저장하고 현재는 그 전의 상태(=이전 커밋 상태)로 되돌림. 즉, working directory 내 변경 내역 있는 파일은 없음.
    
    🔄 다시 복구하고 싶다면?
    
    - `git stash apply` 또는 `git stash pop` 명령으로 저장했던 스냅샷을 다시 적용할 수 있어요.
    
    📦 한 가지 팁:
    
    - stash는 여러 번 저장할 수 있으며, 각각의 stash는 리스트로 관리됩니다 (`git stash list`).

새 프로젝트 수행 시

1. 깃, 소스트리(GUI 버전의 깃), 깃허브 설치
2. 깃 설치 후 설정

`git config--global [user.name](http://user.name/) "영문이름 또는 닉네임"` ➔ 버전을 만든 사람을 알기 위함
`git config--global user.email "이메일계정`

1. 소스 트리 - 깃허브 연동
    1. 기본 웹브라우저에 깃허브 아이디로 로그인이 되어 있어야 함.
    2. HTTPS 방식의 아이디/비밀번호를 통해 연동하는 방식
    3. SSH 공개키/개인키 방식을 통해 연동하는 방식 → **이 경우에 인증된 PC로만 연동할 수 있으며, 네트워크 보안에 따라 연동이 제한될 수도 있음.**
2. 깃허브를 통해 새 repository 생성
3. 소스트리를 통해 깃허브에서 생성된 레포지토리를 clone
4. 로컬 저장소에서 변경 내용 생성
5. add → commit → push
6. 6번과 7번을 반복하여 버전을 쌓아감.